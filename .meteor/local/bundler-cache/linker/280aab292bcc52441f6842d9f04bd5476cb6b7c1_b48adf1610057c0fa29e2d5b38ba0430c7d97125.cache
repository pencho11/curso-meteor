[{"type":"js","data":"//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n\n\n(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\n\n/* Package-scope variables */\nvar EventEmitter;\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// packages/raix_eventemitter/eventemitter.client.js                                                                  //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\n/* global EventEmitter: true */\nEventEmitter = function(options) {\n  var self = this;\n  // Check that the user uses \"new\" keyword for api consistency\n  if (! (self instanceof EventEmitter)) {\n    throw new Error('use \"new\" to construct an EventEmitter');\n  }\n\n  options = options || {};\n\n  // Hidden scope\n  self._eventEmitter = {\n    onListeners: {},\n    onceListeners: {},\n    maxListeners: options.maxListeners || 10\n  };\n};\n\nvar _checkListenerLimit = function(eventName, listenerCount) {\n  var self = this;\n  // Check if we are to send a warning\n  if (self._eventEmitter.maxListeners && listenerCount > self._eventEmitter.maxListeners) {\n    // Return string\n    return 'warning: possible EventEmitter memory leak detected. ' +\n        listenerCount + ' listeners added on event \"' + eventName +\n        '\". Use emitter.setMaxListeners() to increase limit. (' +\n        self._eventEmitter.maxListeners + ')';\n\n  }\n};\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added for a particular event. This is a useful default which helps finding\n// memory leaks. Obviously not all Emitters should be limited to 10. This function\n// allows that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  this._eventEmitter.maxListeners = n;\n};\n\nvar _addToList = function(list, eventName, listener) {\n  // Check that we have a container for the event, Create listener array\n  if (typeof list[eventName] === 'undefined') {\n    list[eventName] = [];\n  }\n\n  // Make sure the listener is not in there already?\n  // We have to comment this to be compliant with node.js\n  // list[eventName] = _.without(list[eventName], listener);\n\n  // Add the listener and Check the limit\n  return _checkListenerLimit.apply(this, [eventName, list[eventName].push(listener)]);\n};\n\n// Adds a listener to the end of the listeners array for the specified event.\n// server.on('connection', function (stream) {\n//   console.log('someone connected!');\n// });\n// Returns emitter, so calls can be chained.\nEventEmitter.prototype.on = function(eventName, listener) {\n  var warn = _addToList.apply(this, [this._eventEmitter.onListeners, eventName, listener]);\n\n  // Warn if needed\n  if (warn) {\n    console.warn((new Error(warn)).stack);\n  }\n\n  // Return the emitter\n  return this;\n};\n\n// Adds a one time listener for the event. This listener is invoked\n// only the next time the event is fired, after which it is removed.\nEventEmitter.prototype.once = function(eventName, listener) {\n  var warn = _addToList.apply(this, [this._eventEmitter.onceListeners, eventName, listener]);\n\n  // Warn if needed\n  if (warn) {\n    console.warn((new Error(warn)).stack);\n  }\n\n  // Return the emitter\n  return this;\n};\n\nvar _runCallbacks = function(listenerArray, args) {\n  var self = this;\n  // count of listeners triggered\n  var count = 0;\n  // Check if we have anything to work with\n  if (typeof listenerArray !== 'undefined') {\n    // Try to iterate over the listeners\n    listenerArray.forEach(function(listener) {\n      // Count listener calls\n      count++;\n      // Send the job to the eventloop\n      listener.apply(self, args);\n    });\n  }\n\n  // Return the count\n  return count;\n};\n\n// emitter.emit(event, [arg1], [arg2], [...])#\n// Execute each of the listeners in order with the supplied arguments.\nEventEmitter.prototype.emit = function(eventName /* arguments */) {\n  var self = this;\n  // make argument list to pass on to listeners\n  var args = Array.prototype.slice.call(arguments, 1);\n\n  // Count listeners triggered\n  var count = 0;\n\n  // Swap once list\n  var onceList = self._eventEmitter.onceListeners[eventName];\n\n  // Empty the once list\n  self._eventEmitter.onceListeners[eventName] = [];\n\n  // Trigger on listeners\n  count += _runCallbacks.call(self, self._eventEmitter.onListeners[eventName], args);\n\n  // Trigger once listeners\n  count += _runCallbacks.call(self, onceList, args);\n\n  // Returns true if event had listeners, false otherwise.\n  return (count > 0);\n};\n\n// XXX: When removing a listener in node js it only removes one - not all.\nvar _withoutOne = function(list, obj) {\n  var found = false;\n  var result = [];\n\n  // Iterate over listeners\n  for (var i = 0; i < list.length; i++) {\n    // Check if we found one...\n    if (!found && list[i] === obj) {\n      found = true;\n    } else {\n      result.push(list[i]);\n    }\n  }\n\n  // return the new array\n  return result;\n};\n\n// Removes all listeners, or those of the specified event. It's not a\n// good idea to remove listeners that were added elsewhere in the code,\n// especially when it's on an emitter that you didn't create (e.g. sockets\n// or file streams).\n// Returns emitter, so calls can be chained.\nEventEmitter.prototype.off = function(eventName, listener) {\n  var self = this;\n  if (eventName) {\n    if (typeof listener === 'function') {\n      // its a bit more tricky - we have to iterate over the arrays and only\n      // clone listeners not equal to\n      if (typeof self._eventEmitter.onListeners[eventName] !== 'undefined') {\n        self._eventEmitter.onListeners[eventName] = _withoutOne(self._eventEmitter.onListeners[eventName], listener);\n\n      }\n      if (typeof self._eventEmitter.onceListeners[eventName] !== 'undefined') {\n        self._eventEmitter.onceListeners[eventName] = _withoutOne(self._eventEmitter.onceListeners[eventName], listener);\n\n      }\n    } else {\n      // Remove all listeners for eventName\n      self._eventEmitter.onListeners[eventName] = [];\n      self._eventEmitter.onceListeners[eventName] = [];\n    }\n\n  } else {\n    // Remove all listeners\n    self._eventEmitter.onListeners = {};\n    self._eventEmitter.onceListeners = {};\n  }\n};\n\n// Add api helpers\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\nEventEmitter.prototype.removeListener = EventEmitter.prototype.off;\nEventEmitter.prototype.removeAllListeners = EventEmitter.prototype.off;\n\n// Add jquery like helpers\nEventEmitter.prototype.one = EventEmitter.prototype.once;\nEventEmitter.prototype.trigger = EventEmitter.prototype.emit;\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nPackage._define(\"raix:eventemitter\", {\n  EventEmitter: EventEmitter\n});\n\n})();\n","servePath":"/packages/raix_eventemitter.js"}]