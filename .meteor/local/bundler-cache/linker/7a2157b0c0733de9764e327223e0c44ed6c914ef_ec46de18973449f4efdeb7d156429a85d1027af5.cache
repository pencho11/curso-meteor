[{"type":"js","data":"//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n\n\n(function () {\n\n/* Imports */\nvar meteorInstall = Package.modules.meteorInstall;\nvar meteorBabelHelpers = Package.modules.meteorBabelHelpers;\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"hot-module-replacement\":{\"hot-api.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                         //\n// packages/hot-module-replacement/hot-api.js                                                              //\n//                                                                                                         //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                           //\nconst meteorInstall = Package['modules-runtime'].meteorInstall;\n\n/**\n * @summary The Hot API used to configure HMR\n * @memberof module\n * @name hot\n */\nObject.defineProperty(meteorInstall.Module.prototype, \"hot\", {\n  get: function () {\n    if (!this._hotState) {\n      this._hotState = {\n        // if null, whether it accepts depends on all of the modules that\n        // required it\n        _hotAccepts: null,\n        _disposeHandlers: [],\n        data: null\n      };\n    }\n\n    let hotState = this._hotState;\n    let module = this;\n\n    return {\n      /**\n       * @summary Accept updates to this module. Also applies to its dependencies,\n       * as long as the other modules that import the dependencies also accept\n       * updates.\n       * @locus Client\n       * @memberOf module.hot\n       * @instance\n       * @name accept\n       */\n      accept() {\n        if (arguments.length > 0) {\n          console.warn('hot.accept does not support any arguments.');\n        }\n        hotState._hotAccepts = true;\n      },\n      /**\n        * @summary Disable updating this module or its dependencies with HMR.\n        * Hot code push will be used instead.\n        * @locus Client\n        * @memberOf module.hot\n        * @instance\n        * @name decline\n        */\n      decline() {\n        if (arguments.length > 0) {\n          throw new Error('hot.decline does not support any arguments.');\n        }\n\n        hotState._hotAccepts = false;\n      },\n      /**\n        * @summary Add a call back to clean up the module before replacing it\n        * @locus Client\n        * @memberOf module.hot\n        * @instance\n        * @name dispose\n        * @param {module.hot.DisposeFunction} callback Called before replacing the old module.\n        */\n      dispose(cb) {\n        hotState._disposeHandlers.push(cb);\n      },\n      /**\n        * @summary Add callbacks to run before and after a module is required\n        * @locus Client\n        * @memberOf module.hot\n        * @instance\n        * @name onRequire\n        * @param {Object} callbacks Can have before and after methods, called before a module is required,\n        * and after it finished being evaluated\n        */\n      onRequire(callbacks) {\n        return module._onRequire(callbacks);\n      },\n      _canAcceptUpdate() {\n        return hotState._hotAccepts;\n      },\n      /**\n       * @summary Defaults to null. When the module is replaced,\n       * this is set to the object passed to dispose handlers.\n       * @locus Client\n       * @memberOf module.hot\n       * @instance\n       * @name data\n       */\n      data: hotState.data\n    }\n  },\n  set() { }\n});\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"client.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                         //\n// packages/hot-module-replacement/client.js                                                               //\n//                                                                                                         //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                           //\n// TODO: add an api to Reify to update cached exports for a module\nconst ReifyEntry = require('/node_modules/meteor/modules/node_modules/reify/lib/runtime/entry.js')\n\nconst SOURCE_URL_PREFIX = \"meteor://\\u{1f4bb}app\";\n\n// Due to the bundler and proxy running in the same node process\n// this could possibly be ran after the next build finished\n// TODO: the builder should inject a build timestamp in the bundle\nlet lastUpdated = Date.now();\nlet appliedChangeSets = [];\nlet removeErrorMessage = null;\n\nlet arch = __meteor_runtime_config__.isModern ? 'web.browser' : 'web.browser.legacy';\nconst hmrSecret = __meteor_runtime_config__._hmrSecret;\nlet supportedArch = arch === 'web.browser';\nconst enabled = hmrSecret && supportedArch;\n\nif (!supportedArch) {\n  console.log(`HMR is not supported in ${arch}`);\n}\n\nif (!hmrSecret) {\n  console.log('Restart Meteor to enable HMR');\n}\n\nconst imported = Object.create(null);\nconst importedBy = Object.create(null);\n\nif (module._onRequire) {\n  module._onRequire({\n    before(importedModule, parentId) {\n      if (parentId === module.id) {\n        // While applying updates we import modules to re-run them.\n        // Don't track those imports since we don't want them to affect\n        // if a future change to the file can be accepted\n        return;\n      }\n      imported[parentId] = imported[parentId] || new Set();\n      imported[parentId].add(importedModule.id);\n\n      importedBy[importedModule.id] = importedBy[importedModule.id] || new Set();\n      importedBy[importedModule.id].add(parentId);\n    },\n  });\n}\n\nlet pendingReload = () => Package['reload'].Reload._reload({ immediateMigration: true });\nlet mustReload = false;\n// Once an eager update fails, we stop processing future updates since they\n// might depend on the failed update. This gets reset when we re-try applying\n// the changes as non-eager updates.\nlet applyEagerUpdates = true;\n\nfunction handleMessage(message) {\n  if (message.type === 'register-failed') {\n    if (message.reason === 'wrong-app') {\n      console.log('HMR: A different app is running on', Meteor.absoluteUrl());\n      console.log('HMR: Once you start this app again reload the page to re-enable HMR');\n    } else if (message.reason === 'wrong-secret') {\n      console.log('HMR: Have the wrong secret, probably because Meteor was restarted');\n      console.log('HMR: Will enable HMR the next time the page is loaded');\n      mustReload = true;\n    } else {\n      console.log(`HMR: Register failed for unknown reason`, message);\n    }\n    return;\n  } else if (message.type === 'app-state') {\n    if (removeErrorMessage) {\n      removeErrorMessage();\n    }\n\n    if (message.state === 'error' && Package['dev-error-overlay']) {\n      removeErrorMessage = Package['dev-error-overlay']\n        .DevErrorOverlay\n        .showMessage('Your app is crashing. Here are the latest logs:', message.log.join('\\n'));\n    }\n\n    return;\n  }\n\n  if (message.type !== 'changes') {\n    throw new Error(`Unknown HMR message type ${message.type}`);\n  }\n\n  if (message.eager && !applyEagerUpdates) {\n    return;\n  } else if (!message.eager) {\n    // Now that the build has finished, we will finish handling any updates\n    // that failed while being eagerly applied. Afterwards, we will either\n    // fall back to hot code push, or be in a state where we can start handling\n    // eager updates again\n    applyEagerUpdates = true;\n  }\n\n  const hasUnreloadable = message.changeSets.find(changeSet => {\n    return !changeSet.reloadable;\n  });\n\n  if (\n    pendingReload &&\n    hasUnreloadable ||\n    message.changeSets.length === 0\n  ) {\n    if (message.eager) {\n      // This was an attempt to reload before the build finishes\n      // If we can't, we will wait until the build finishes to properly handle it\n      // For now, we will disable eager updates in case future updates depended\n      // on these\n      applyEagerUpdates = false;\n      return;\n    }\n\n    console.log('HMR: Unable to do HMR. Falling back to hot code push.')\n    // Complete hot code push if we can not do hot module reload\n    mustReload = true;\n    return pendingReload();\n  }\n\n  // In case the user changed how a module works with HMR\n  // in one of the earlier change sets, we want to apply each\n  // change set one at a time in order.\n  const succeeded = message.changeSets.filter(changeSet => {\n    return !appliedChangeSets.includes(changeSet.id)\n  }).every(changeSet => {\n    const applied = applyChangeset(changeSet, message.eager);\n\n    // We don't record if a module is unreplaceable\n    // during an eager update so we can retry and\n    // handle the failure after the build finishes\n    if (applied || !message.eager) {\n      appliedChangeSets.push(changeSet.id);\n    }\n\n    return applied;\n  });\n\n  if (message.eager) {\n    // If there were any failures, we will stop applying eager updates for now\n    // and wait until after the build finishes to handle the failures\n    applyEagerUpdates = succeeded;\n    return;\n  }\n\n  if (!succeeded) {\n    if (pendingReload) {\n      console.log('HMR: Some changes can not be applied with HMR. Using hot code push.')\n      mustReload = true;\n      return pendingReload();\n    }\n\n    throw new Error('HMR failed and unable to fallback to hot code push?');\n  }\n\n  if (message.changeSets.length > 0) {\n    lastUpdated = message.changeSets[message.changeSets.length - 1].linkedAt;\n  }\n}\n\nlet socket;\nlet disconnected = false;\nlet pendingMessages = [];\n\nfunction send(message) {\n  if (socket) {\n    socket.send(JSON.stringify(message));\n  } else {\n    pendingMessages.push(message);\n  }\n}\n\nfunction connect() {\n  if (mustReload) {\n    // The page will reload, no reason to\n    // connect and show more logs in the console\n    return;\n  }\n\n  // If we've successfully connected and then was disconnected, we avoid showing\n  // any more connection errors in the console until we've connected again\n  let logDisconnect = !disconnected;\n  let wsUrl = Meteor.absoluteUrl('__meteor__hmr__/websocket');\n  const protocol = wsUrl.startsWith('https://') ? 'wss://' : 'ws://';\n  wsUrl = wsUrl.replace(/^.+\\/\\//, protocol);\n  socket = new WebSocket(wsUrl);\n\n  socket.addEventListener('close', function () {\n    socket = null;\n\n    if (logDisconnect) {\n      console.log('HMR: websocket closed');\n    }\n\n    disconnected = true;\n    setTimeout(connect, 2000);\n  });\n\n  socket.addEventListener('open', function () {\n    logDisconnect = true;\n    disconnected = false;\n\n    console.log('HMR: connected');\n    socket.send(JSON.stringify({\n      type: 'register',\n      arch,\n      secret: hmrSecret,\n      appId: __meteor_runtime_config__.appId,\n    }));\n\n    const toSend = pendingMessages.slice();\n    pendingMessages = [];\n\n    toSend.forEach(message => {\n      send(message);\n    });\n  });\n\n  socket.addEventListener('message', function (event) {\n    handleMessage(JSON.parse(event.data));\n  });\n}\n\nif (enabled) {\n  connect();\n} else {\n  // Always fall back to hot code push if HMR is disabled\n  mustReload = true;\n}\n\nfunction requestChanges() {\n  send({\n    type: 'request-changes',\n    arch,\n    after: lastUpdated\n  });\n}\n\nfunction walkTree(pathParts, tree) {\n  const part = pathParts.shift();\n  const _module = tree.contents[part];\n\n  if (!_module) {\n    console.log('HMR: file does not exist', part, pathParts, _module, tree);\n    throw new Error('not-exist');\n  }\n\n  if (pathParts.length === 0) {\n    return _module;\n  }\n\n  return walkTree(pathParts, _module);\n}\n\nfunction findFile(moduleId) {\n  return walkTree(moduleId.split('/').slice(1), module._getRoot());\n}\n\n// btoa with unicode support\nfunction utoa(data) {\n  return btoa(unescape(encodeURIComponent(data)));\n}\n\nfunction createInlineSourceMap(map) {\n  return \"//# sourceMappingURL=data:application/json;base64,\" + utoa(JSON.stringify(map));\n}\n\nfunction createModuleContent (code, map) {\n  return function () {\n    return eval(\n      // Wrap the function(require,exports,module){...} expression in\n      // parentheses to force it to be parsed as an expression.\n      // The sourceURL is treated as a prefix for the sources array\n      // in the source map\n      \"(\" + code + \")\\n//# sourceURL=\" + SOURCE_URL_PREFIX +\n      \"\\n\" + createInlineSourceMap(map)\n    ).apply(this, arguments);\n  }\n}\n\nfunction replaceFileContent(file, contents) {\n  // TODO: to replace content in packages, we need an eval function that runs\n  // within the package scope, like dynamic imports does.\n  const moduleFunction = createModuleContent(contents.code, contents.map, file.module.id);\n\n  file.contents = moduleFunction;\n}\n\nfunction checkModuleAcceptsUpdate(moduleId, checked) {\n  checked.add(moduleId);\n  \n  if (moduleId === '/' ) {\n    return false;\n  }\n  \n  const file = findFile(moduleId);\n  const moduleHot = file.module.hot;\n  const moduleAccepts = moduleHot ? moduleHot._canAcceptUpdate() : false;\n\n  if (moduleAccepts !== null) {\n    return moduleAccepts;\n  }\n\n  let accepts = null;\n\n  // The module did not accept the update. If the update is accepted depends\n  // on if the modules that imported this module accept the update.\n  importedBy[moduleId].forEach(depId => {\n    if (depId === '/' && importedBy[moduleId].size > 1) {\n      // This module was eagerly required by Meteor.\n      // Meteor won't know if the module can be updated\n      // but we can check with the other modules that imported it.\n      return;\n    }\n\n    if (checked.has(depId)) {\n      // There is a circular dependency\n      return;\n    }\n\n    const depResult = checkModuleAcceptsUpdate(depId, checked);\n\n    if (accepts !== false) {\n      accepts = depResult;\n    }\n  });\n\n  return accepts === null ? false : accepts;\n}\n\nfunction addFiles(addedFiles) {\n  addedFiles.forEach(file => {\n    const tree = {};\n    const segments = file.path.split('/').slice(1);\n    const fileName = segments.pop();\n\n    let previous = tree;\n    segments.forEach(segment => {\n      previous[segment] = previous[segment] || {}\n      previous = previous[segment]\n    });\n    previous[fileName] = createModuleContent(\n      file.content.code,\n      file.content.map,\n      file.path\n    );\n\n    meteorInstall(tree, file.meteorInstallOptions);\n  });\n}\n\nmodule.constructor.prototype._reset = function (id) {\n  const moduleId = id || this.id;\n  const file = findFile(moduleId);\n\n  const hotState = file.module._hotState;\n\n  const hotData = {};\n  hotState._disposeHandlers.forEach(cb => {\n    cb(hotData);\n  });\n\n  hotState.data = hotData;\n  hotState._disposeHandlers = [];\n  hotState._hotAccepts = null;\n\n\n  // Clear cached exports\n  // TODO: check how this affects live bindings for ecmascript modules\n  delete file.module.exports;\n  const entry = ReifyEntry.getOrCreate(moduleId);\n  entry.getters = {};\n  entry.setters = {};\n  entry.module = null;\n  Object.keys(entry.namespace).forEach(key => {\n    if (key !== '__esModule') {\n      delete entry.namespace[key];\n    }\n  });\n\n  if (imported[moduleId]) {\n    imported[moduleId].forEach(depId => {\n      importedBy[depId].delete(moduleId);\n    });\n    imported[moduleId] = new Set();\n  }\n}\n\nmodule.constructor.prototype._replaceModule = function (id, contents) {\n  const moduleId = id || this.id;\n  const root = this._getRoot();\n\n  let file;\n  try {\n    file = walkTree(moduleId.split('/').slice(1), root);\n  } catch (e) {\n    if (e.message === 'not-exist') {\n      return null;\n    }\n\n    throw e;\n  }\n\n  if (!file.contents) {\n    // File is a dynamic import that hasn't been loaded\n    return;\n  }\n\n  replaceFileContent(file, contents);\n\n  if (!file.module.exports) {\n    // File hasn't been imported.\n    return;\n  }\n}\n\nfunction applyChangeset({\n  changedFiles,\n  addedFiles\n}) {\n  let canApply = true;\n  let toRerun = new Set();\n\n  changedFiles.forEach(({ path }) => {\n    const file = findFile(path);\n\n    // Check if the file has been imported. If it hasn't been,\n    // we can assume update to it can be accepted\n    if (file.module.exports) {\n      const checked = new Set();\n      const accepts = checkModuleAcceptsUpdate(path, checked);\n\n      if (canApply) {\n        canApply = accepts;\n        checked.forEach(moduleId => {\n          toRerun.add(moduleId);\n        });\n      }\n    }\n  });\n\n  if (!canApply) {\n    return false;\n  }\n\n\n  changedFiles.forEach(({ content, path }) => {\n    module._replaceModule(path, content);\n  });\n\n  if (addedFiles.length > 0) {\n    addFiles(addedFiles);\n  }\n\n  toRerun.forEach(moduleId => {\n    const file = findFile(moduleId);\n    // clear module caches and hot state\n    file.module._reset();\n    file.module.loaded = false;\n  });\n\n  try {\n    toRerun.forEach(moduleId => {\n      require(moduleId);\n    });\n  } catch (error) {\n    console.error('HMR: Error while applying changes:', error);\n  }\n\n  const updateCount = changedFiles.length + addedFiles.length;\n  console.log(`HMR: updated ${updateCount} ${updateCount === 1 ? 'file' : 'files'}`);\n  return true;\n}\n\nconst initialVersions = (__meteor_runtime_config__.autoupdate.versions || {})['web.browser'];\nlet nonRefreshableVersion = initialVersions.versionNonRefreshable;\nlet replaceableVersion = initialVersions.versionReplaceable;\n\nMeteor.startup(() => {\n  if (!supportedArch) {\n    return;\n  }\n\n  Package['autoupdate'].Autoupdate._clientVersions.watch((doc) => {\n    if (doc._id !== 'web.browser') {\n      return;\n    }\n\n    if (nonRefreshableVersion !== doc.versionNonRefreshable) {\n      nonRefreshableVersion = doc.versionNonRefreshable;\n      console.log('HMR: Some changes can not be applied with HMR. Using hot code push.')\n      mustReload = true;\n      pendingReload();\n    } else if (doc.versionReplaceable !== replaceableVersion) {\n      replaceableVersion = doc.versionReplaceable;\n      if (enabled && !mustReload) {\n        requestChanges();\n      } else {\n        mustReload = true;\n        pendingReload();\n      }\n    }\n  });\n\n  // We disable hot code push for js until there were\n  // changes that can not be applied through HMR.\n  Package['reload'].Reload._onMigrate((tryReload) => {\n    if (mustReload) {\n      return [true];\n    }\n\n    pendingReload = tryReload;\n    requestChanges();\n\n    return [false];\n  });\n});\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}}},{\n  \"extensions\": [\n    \".js\",\n    \".json\"\n  ]\n});\n\nrequire(\"/node_modules/meteor/hot-module-replacement/hot-api.js\");\nrequire(\"/node_modules/meteor/hot-module-replacement/client.js\");\n\n/* Exports */\nPackage._define(\"hot-module-replacement\");\n\n})();\n","servePath":"/packages/hot-module-replacement.js"}]