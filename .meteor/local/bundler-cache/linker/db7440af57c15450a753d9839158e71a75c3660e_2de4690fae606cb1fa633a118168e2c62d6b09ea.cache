[{"type":"js","data":"//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n\n\n(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar Accounts = Package['accounts-base'].Accounts;\nvar Tracker = Package.tracker.Tracker;\nvar Deps = Package.tracker.Deps;\nvar Mongo = Package.mongo.Mongo;\nvar check = Package.check.check;\nvar Match = Package.check.Match;\nvar meteorInstall = Package.modules.meteorInstall;\nvar Promise = Package.promise.Promise;\n\n/* Package-scope variables */\nvar Roles;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"alanning:roles\":{\"roles\":{\"roles_common.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/alanning_roles/roles/roles_common.js                                                                       //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n!function (module1) {\n  /* global Meteor, Roles, Mongo */\n\n  /**\n   * Provides functions related to user authorization. Compatible with built-in Meteor accounts packages.\n   *\n   * Roles are accessible throgh `Meteor.roles` collection and documents consist of:\n   *  - `_id`: role name\n   *  - `children`: list of subdocuments:\n   *    - `_id`\n   *\n   * Children list elements are subdocuments so that they can be easier extended in the future or by plugins.\n   *\n   * Roles can have multiple parents and can be children (subroles) of multiple roles.\n   *\n   * Example: `{_id: 'admin', children: [{_id: 'editor'}]}`\n   *\n   * The assignment of a role to a user is stored in a collection, accessible through `Meteor.roleAssignment`.\n   * It's documents consist of\n   *  - `_id`: Internal MongoDB id\n   *  - `role`: A role object which got assigned. Usually only contains the `_id` property\n   *  - `user`: A user object, usually only contains the `_id` property\n   *  - `scope`: scope name\n   *  - `inheritedRoles`: A list of all the roles objects inherited by the assigned role.\n   *\n   * @module Roles\n   */\n  if (!Meteor.roles) {\n    Meteor.roles = new Mongo.Collection('roles');\n  }\n\n  if (!Meteor.roleAssignment) {\n    Meteor.roleAssignment = new Mongo.Collection('role-assignment');\n  }\n  /**\n   * @class Roles\n   */\n\n\n  if (typeof Roles === 'undefined') {\n    Roles = {}; // eslint-disable-line no-global-assign\n  }\n\n  var getGroupsForUserDeprecationWarning = false;\n  Object.assign(Roles, {\n    /**\n     * Used as a global group (now scope) name. Not used anymore.\n     *\n     * @property GLOBAL_GROUP\n     * @static\n     * @deprecated\n     */\n    GLOBAL_GROUP: null,\n\n    /**\n     * Create a new role.\n     *\n     * @method createRole\n     * @param {String} roleName Name of role.\n     * @param {Object} [options] Options:\n     *   - `unlessExists`: if `true`, exception will not be thrown in the role already exists\n     * @return {String} ID of the new role or null.\n     * @static\n     */\n    createRole: function (roleName, options) {\n      Roles._checkRoleName(roleName);\n\n      options = Object.assign({\n        unlessExists: false\n      }, options);\n      var result = Meteor.roles.upsert({\n        _id: roleName\n      }, {\n        $setOnInsert: {\n          children: []\n        }\n      });\n\n      if (!result.insertedId) {\n        if (options.unlessExists) return null;\n        throw new Error('Role \\'' + roleName + '\\' already exists.');\n      }\n\n      return result.insertedId;\n    },\n\n    /**\n     * Delete an existing role.\n     *\n     * If the role is set for any user, it is automatically unset.\n     *\n     * @method deleteRole\n     * @param {String} roleName Name of role.\n     * @static\n     */\n    deleteRole: function (roleName) {\n      var roles;\n      var inheritedRoles;\n\n      Roles._checkRoleName(roleName); // Remove all assignments\n\n\n      Meteor.roleAssignment.remove({\n        'role._id': roleName\n      });\n\n      do {\n        // For all roles who have it as a dependency ...\n        roles = Roles._getParentRoleNames(Meteor.roles.findOne({\n          _id: roleName\n        }));\n        Meteor.roles.find({\n          _id: {\n            $in: roles\n          }\n        }).fetch().forEach(r => {\n          Meteor.roles.update({\n            _id: r._id\n          }, {\n            $pull: {\n              children: {\n                _id: roleName\n              }\n            }\n          });\n          inheritedRoles = Roles._getInheritedRoleNames(Meteor.roles.findOne({\n            _id: r._id\n          }));\n          Meteor.roleAssignment.update({\n            'role._id': r._id\n          }, {\n            $set: {\n              inheritedRoles: [r._id, ...inheritedRoles].map(r2 => ({\n                _id: r2\n              }))\n            }\n          }, {\n            multi: true\n          });\n        });\n      } while (roles.length > 0); // And finally remove the role itself\n\n\n      Meteor.roles.remove({\n        _id: roleName\n      });\n    },\n\n    /**\n     * Rename an existing role.\n     *\n     * @method renameRole\n     * @param {String} oldName Old name of a role.\n     * @param {String} newName New name of a role.\n     * @static\n     */\n    renameRole: function (oldName, newName) {\n      var role;\n      var count;\n\n      Roles._checkRoleName(oldName);\n\n      Roles._checkRoleName(newName);\n\n      if (oldName === newName) return;\n      role = Meteor.roles.findOne({\n        _id: oldName\n      });\n\n      if (!role) {\n        throw new Error('Role \\'' + oldName + '\\' does not exist.');\n      }\n\n      role._id = newName;\n      Meteor.roles.insert(role);\n\n      do {\n        count = Meteor.roleAssignment.update({\n          'role._id': oldName\n        }, {\n          $set: {\n            'role._id': newName\n          }\n        }, {\n          multi: true\n        });\n      } while (count > 0);\n\n      do {\n        count = Meteor.roleAssignment.update({\n          'inheritedRoles._id': oldName\n        }, {\n          $set: {\n            'inheritedRoles.$._id': newName\n          }\n        }, {\n          multi: true\n        });\n      } while (count > 0);\n\n      do {\n        count = Meteor.roles.update({\n          'children._id': oldName\n        }, {\n          $set: {\n            'children.$._id': newName\n          }\n        }, {\n          multi: true\n        });\n      } while (count > 0);\n\n      Meteor.roles.remove({\n        _id: oldName\n      });\n    },\n\n    /**\n     * Add role parent to roles.\n     *\n     * Previous parents are kept (role can have multiple parents). For users which have the\n     * parent role set, new subroles are added automatically.\n     *\n     * @method addRolesToParent\n     * @param {Array|String} rolesNames Name(s) of role(s).\n     * @param {String} parentName Name of parent role.\n     * @static\n     */\n    addRolesToParent: function (rolesNames, parentName) {\n      // ensure arrays\n      if (!Array.isArray(rolesNames)) rolesNames = [rolesNames];\n      rolesNames.forEach(function (roleName) {\n        Roles._addRoleToParent(roleName, parentName);\n      });\n    },\n\n    /**\n     * @method _addRoleToParent\n     * @param {String} roleName Name of role.\n     * @param {String} parentName Name of parent role.\n     * @private\n     * @static\n     */\n    _addRoleToParent: function (roleName, parentName) {\n      var role;\n      var count;\n\n      Roles._checkRoleName(roleName);\n\n      Roles._checkRoleName(parentName); // query to get role's children\n\n\n      role = Meteor.roles.findOne({\n        _id: roleName\n      });\n\n      if (!role) {\n        throw new Error('Role \\'' + roleName + '\\' does not exist.');\n      } // detect cycles\n\n\n      if (Roles._getInheritedRoleNames(role).includes(parentName)) {\n        throw new Error('Roles \\'' + roleName + '\\' and \\'' + parentName + '\\' would form a cycle.');\n      }\n\n      count = Meteor.roles.update({\n        _id: parentName,\n        'children._id': {\n          $ne: role._id\n        }\n      }, {\n        $push: {\n          children: {\n            _id: role._id\n          }\n        }\n      }); // if there was no change, parent role might not exist, or role is\n      // already a subrole; in any case we do not have anything more to do\n\n      if (!count) return;\n      Meteor.roleAssignment.update({\n        'inheritedRoles._id': parentName\n      }, {\n        $push: {\n          inheritedRoles: {\n            $each: [role._id, ...Roles._getInheritedRoleNames(role)].map(r => ({\n              _id: r\n            }))\n          }\n        }\n      }, {\n        multi: true\n      });\n    },\n\n    /**\n     * Remove role parent from roles.\n     *\n     * Other parents are kept (role can have multiple parents). For users which have the\n     * parent role set, removed subrole is removed automatically.\n     *\n     * @method removeRolesFromParent\n     * @param {Array|String} rolesNames Name(s) of role(s).\n     * @param {String} parentName Name of parent role.\n     * @static\n     */\n    removeRolesFromParent: function (rolesNames, parentName) {\n      // ensure arrays\n      if (!Array.isArray(rolesNames)) rolesNames = [rolesNames];\n      rolesNames.forEach(function (roleName) {\n        Roles._removeRoleFromParent(roleName, parentName);\n      });\n    },\n\n    /**\n     * @method _removeRoleFromParent\n     * @param {String} roleName Name of role.\n     * @param {String} parentName Name of parent role.\n     * @private\n     * @static\n     */\n    _removeRoleFromParent: function (roleName, parentName) {\n      Roles._checkRoleName(roleName);\n\n      Roles._checkRoleName(parentName); // check for role existence\n      // this would not really be needed, but we are trying to match addRolesToParent\n\n\n      let role = Meteor.roles.findOne({\n        _id: roleName\n      }, {\n        fields: {\n          _id: 1\n        }\n      });\n\n      if (!role) {\n        throw new Error('Role \\'' + roleName + '\\' does not exist.');\n      }\n\n      const count = Meteor.roles.update({\n        _id: parentName\n      }, {\n        $pull: {\n          children: {\n            _id: role._id\n          }\n        }\n      }); // if there was no change, parent role might not exist, or role was\n      // already not a subrole; in any case we do not have anything more to do\n\n      if (!count) return; // For all roles who have had it as a dependency ...\n\n      const roles = [...Roles._getParentRoleNames(Meteor.roles.findOne({\n        _id: parentName\n      })), parentName];\n      Meteor.roles.find({\n        _id: {\n          $in: roles\n        }\n      }).fetch().forEach(r => {\n        const inheritedRoles = Roles._getInheritedRoleNames(Meteor.roles.findOne({\n          _id: r._id\n        }));\n\n        Meteor.roleAssignment.update({\n          'role._id': r._id,\n          'inheritedRoles._id': role._id\n        }, {\n          $set: {\n            inheritedRoles: [r._id, ...inheritedRoles].map(r2 => ({\n              _id: r2\n            }))\n          }\n        }, {\n          multi: true\n        });\n      });\n    },\n\n    /**\n     * Add users to roles.\n     *\n     * Adds roles to existing roles for each user.\n     *\n     * @example\n     *     Roles.addUsersToRoles(userId, 'admin')\n     *     Roles.addUsersToRoles(userId, ['view-secrets'], 'example.com')\n     *     Roles.addUsersToRoles([user1, user2], ['user','editor'])\n     *     Roles.addUsersToRoles([user1, user2], ['glorious-admin', 'perform-action'], 'example.org')\n     *\n     * @method addUsersToRoles\n     * @param {Array|String} users User ID(s) or object(s) with an `_id` field.\n     * @param {Array|String} roles Name(s) of roles to add users to. Roles have to exist.\n     * @param {Object|String} [options] Options:\n     *   - `scope`: name of the scope, or `null` for the global role\n     *   - `ifExists`: if `true`, do not throw an exception if the role does not exist\n     *\n     * Alternatively, it can be a scope name string.\n     * @static\n     */\n    addUsersToRoles: function (users, roles, options) {\n      var id;\n      if (!users) throw new Error('Missing \\'users\\' param.');\n      if (!roles) throw new Error('Missing \\'roles\\' param.');\n      options = Roles._normalizeOptions(options); // ensure arrays\n\n      if (!Array.isArray(users)) users = [users];\n      if (!Array.isArray(roles)) roles = [roles];\n\n      Roles._checkScopeName(options.scope);\n\n      options = Object.assign({\n        ifExists: false\n      }, options);\n      users.forEach(function (user) {\n        if (typeof user === 'object') {\n          id = user._id;\n        } else {\n          id = user;\n        }\n\n        roles.forEach(function (role) {\n          Roles._addUserToRole(id, role, options);\n        });\n      });\n    },\n\n    /**\n     * Set users' roles.\n     *\n     * Replaces all existing roles with a new set of roles.\n     *\n     * @example\n     *     Roles.setUserRoles(userId, 'admin')\n     *     Roles.setUserRoles(userId, ['view-secrets'], 'example.com')\n     *     Roles.setUserRoles([user1, user2], ['user','editor'])\n     *     Roles.setUserRoles([user1, user2], ['glorious-admin', 'perform-action'], 'example.org')\n     *\n     * @method setUserRoles\n     * @param {Array|String} users User ID(s) or object(s) with an `_id` field.\n     * @param {Array|String} roles Name(s) of roles to add users to. Roles have to exist.\n     * @param {Object|String} [options] Options:\n     *   - `scope`: name of the scope, or `null` for the global role\n     *   - `anyScope`: if `true`, remove all roles the user has, of any scope, if `false`, only the one in the same scope\n     *   - `ifExists`: if `true`, do not throw an exception if the role does not exist\n     *\n     * Alternatively, it can be a scope name string.\n     * @static\n     */\n    setUserRoles: function (users, roles, options) {\n      var id;\n      if (!users) throw new Error('Missing \\'users\\' param.');\n      if (!roles) throw new Error('Missing \\'roles\\' param.');\n      options = Roles._normalizeOptions(options); // ensure arrays\n\n      if (!Array.isArray(users)) users = [users];\n      if (!Array.isArray(roles)) roles = [roles];\n\n      Roles._checkScopeName(options.scope);\n\n      options = Object.assign({\n        ifExists: false,\n        anyScope: false\n      }, options);\n      users.forEach(function (user) {\n        if (typeof user === 'object') {\n          id = user._id;\n        } else {\n          id = user;\n        } // we first clear all roles for the user\n\n\n        const selector = {\n          'user._id': id\n        };\n\n        if (!options.anyScope) {\n          selector.scope = options.scope;\n        }\n\n        Meteor.roleAssignment.remove(selector); // and then add all\n\n        roles.forEach(function (role) {\n          Roles._addUserToRole(id, role, options);\n        });\n      });\n    },\n\n    /**\n     * Add one user to one role.\n     *\n     * @method _addUserToRole\n     * @param {String} userId The user ID.\n     * @param {String} roleName Name of the role to add the user to. The role have to exist.\n     * @param {Object} options Options:\n     *   - `scope`: name of the scope, or `null` for the global role\n     *   - `ifExists`: if `true`, do not throw an exception if the role does not exist\n     * @private\n     * @static\n     */\n    _addUserToRole: function (userId, roleName, options) {\n      Roles._checkRoleName(roleName);\n\n      Roles._checkScopeName(options.scope);\n\n      if (!userId) {\n        return;\n      }\n\n      const role = Meteor.roles.findOne({\n        _id: roleName\n      }, {\n        fields: {\n          children: 1\n        }\n      });\n\n      if (!role) {\n        if (options.ifExists) {\n          return [];\n        } else {\n          throw new Error('Role \\'' + roleName + '\\' does not exist.');\n        }\n      } // This might create duplicates, because we don't have a unique index, but that's all right. In case there are two, withdrawing the role will effectively kill them both.\n\n\n      const res = Meteor.roleAssignment.upsert({\n        'user._id': userId,\n        'role._id': roleName,\n        scope: options.scope\n      }, {\n        $setOnInsert: {\n          user: {\n            _id: userId\n          },\n          role: {\n            _id: roleName\n          },\n          scope: options.scope\n        }\n      });\n\n      if (res.insertedId) {\n        Meteor.roleAssignment.update({\n          _id: res.insertedId\n        }, {\n          $set: {\n            inheritedRoles: [roleName, ...Roles._getInheritedRoleNames(role)].map(r => ({\n              _id: r\n            }))\n          }\n        });\n      }\n\n      return res;\n    },\n\n    /**\n     * Returns an array of role names the given role name is a child of.\n     *\n     * @example\n     *     Roles._getParentRoleNames({ _id: 'admin', children; [] })\n     *\n     * @method _getParentRoleNames\n     * @param {object} role The role object\n     * @private\n     * @static\n     */\n    _getParentRoleNames: function (role) {\n      var parentRoles;\n\n      if (!role) {\n        return [];\n      }\n\n      parentRoles = new Set([role._id]);\n      parentRoles.forEach(roleName => {\n        Meteor.roles.find({\n          'children._id': roleName\n        }).fetch().forEach(parentRole => {\n          parentRoles.add(parentRole._id);\n        });\n      });\n      parentRoles.delete(role._id);\n      return [...parentRoles];\n    },\n\n    /**\n     * Returns an array of role names the given role name is a parent of.\n     *\n     * @example\n     *     Roles._getInheritedRoleNames({ _id: 'admin', children; [] })\n     *\n     * @method _getInheritedRoleNames\n     * @param {object} role The role object\n     * @private\n     * @static\n     */\n    _getInheritedRoleNames: function (role) {\n      const inheritedRoles = new Set();\n      const nestedRoles = new Set([role]);\n      nestedRoles.forEach(r => {\n        const roles = Meteor.roles.find({\n          _id: {\n            $in: r.children.map(r => r._id)\n          }\n        }, {\n          fields: {\n            children: 1\n          }\n        }).fetch();\n        roles.forEach(r2 => {\n          inheritedRoles.add(r2._id);\n          nestedRoles.add(r2);\n        });\n      });\n      return [...inheritedRoles];\n    },\n\n    /**\n     * Remove users from assigned roles.\n     *\n     * @example\n     *     Roles.removeUsersFromRoles(userId, 'admin')\n     *     Roles.removeUsersFromRoles([userId, user2], ['editor'])\n     *     Roles.removeUsersFromRoles(userId, ['user'], 'group1')\n     *\n     * @method removeUsersFromRoles\n     * @param {Array|String} users User ID(s) or object(s) with an `_id` field.\n     * @param {Array|String} roles Name(s) of roles to remove users from. Roles have to exist.\n     * @param {Object|String} [options] Options:\n     *   - `scope`: name of the scope, or `null` for the global role\n     *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n     *\n     * Alternatively, it can be a scope name string.\n     * @static\n     */\n    removeUsersFromRoles: function (users, roles, options) {\n      if (!users) throw new Error('Missing \\'users\\' param.');\n      if (!roles) throw new Error('Missing \\'roles\\' param.');\n      options = Roles._normalizeOptions(options); // ensure arrays\n\n      if (!Array.isArray(users)) users = [users];\n      if (!Array.isArray(roles)) roles = [roles];\n\n      Roles._checkScopeName(options.scope);\n\n      users.forEach(function (user) {\n        if (!user) return;\n        roles.forEach(function (role) {\n          let id;\n\n          if (typeof user === 'object') {\n            id = user._id;\n          } else {\n            id = user;\n          }\n\n          Roles._removeUserFromRole(id, role, options);\n        });\n      });\n    },\n\n    /**\n     * Remove one user from one role.\n     *\n     * @method _removeUserFromRole\n     * @param {String} userId The user ID.\n     * @param {String} roleName Name of the role to add the user to. The role have to exist.\n     * @param {Object} options Options:\n     *   - `scope`: name of the scope, or `null` for the global role\n     *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n     * @private\n     * @static\n     */\n    _removeUserFromRole: function (userId, roleName, options) {\n      Roles._checkRoleName(roleName);\n\n      Roles._checkScopeName(options.scope);\n\n      if (!userId) return;\n      const selector = {\n        'user._id': userId,\n        'role._id': roleName\n      };\n\n      if (!options.anyScope) {\n        selector.scope = options.scope;\n      }\n\n      Meteor.roleAssignment.remove(selector);\n    },\n\n    /**\n     * Check if user has specified roles.\n     *\n     * @example\n     *     // global roles\n     *     Roles.userIsInRole(user, 'admin')\n     *     Roles.userIsInRole(user, ['admin','editor'])\n     *     Roles.userIsInRole(userId, 'admin')\n     *     Roles.userIsInRole(userId, ['admin','editor'])\n     *\n     *     // scope roles (global roles are still checked)\n     *     Roles.userIsInRole(user, 'admin', 'group1')\n     *     Roles.userIsInRole(userId, ['admin','editor'], 'group1')\n     *     Roles.userIsInRole(userId, ['admin','editor'], {scope: 'group1'})\n     *\n     * @method userIsInRole\n     * @param {String|Object} user User ID or an actual user object.\n     * @param {Array|String} roles Name of role or an array of roles to check against. If array,\n     *                             will return `true` if user is in _any_ role.\n     *                             Roles do not have to exist.\n     * @param {Object|String} [options] Options:\n     *   - `scope`: name of the scope; if supplied, limits check to just that scope\n     *     the user's global roles will always be checked whether scope is specified or not\n     *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n     *\n     * Alternatively, it can be a scope name string.\n     * @return {Boolean} `true` if user is in _any_ of the target roles\n     * @static\n     */\n    userIsInRole: function (user, roles, options) {\n      var id;\n      var selector;\n      options = Roles._normalizeOptions(options); // ensure array to simplify code\n\n      if (!Array.isArray(roles)) roles = [roles];\n      roles = roles.filter(r => r != null);\n      if (!roles.length) return false;\n\n      Roles._checkScopeName(options.scope);\n\n      options = Object.assign({\n        anyScope: false\n      }, options);\n\n      if (user && typeof user === 'object') {\n        id = user._id;\n      } else {\n        id = user;\n      }\n\n      if (!id) return false;\n      if (typeof id !== 'string') return false;\n      selector = {\n        'user._id': id\n      };\n\n      if (!options.anyScope) {\n        selector.scope = {\n          $in: [options.scope, null]\n        };\n      }\n\n      return roles.some(roleName => {\n        selector['inheritedRoles._id'] = roleName;\n        return Meteor.roleAssignment.find(selector, {\n          limit: 1\n        }).count() > 0;\n      });\n    },\n\n    /**\n     * Retrieve user's roles.\n     *\n     * @method getRolesForUser\n     * @param {String|Object} user User ID or an actual user object.\n     * @param {Object|String} [options] Options:\n     *   - `scope`: name of scope to provide roles for; if not specified, global roles are returned\n     *   - `anyScope`: if set, role can be in any scope (`scope` and `onlyAssigned` options are ignored)\n     *   - `onlyScoped`: if set, only roles in the specified scope are returned\n     *   - `onlyAssigned`: return only assigned roles and not automatically inferred (like subroles)\n     *   - `fullObjects`: return full roles objects (`true`) or just names (`false`) (`onlyAssigned` option is ignored) (default `false`)\n     *     If you have a use-case for this option, please file a feature-request. You shouldn't need to use it as it's\n     *     result strongly dependant on the internal data structure of this plugin.\n     *\n     * Alternatively, it can be a scope name string.\n     * @return {Array} Array of user's roles, unsorted.\n     * @static\n     */\n    getRolesForUser: function (user, options) {\n      var id;\n      var selector;\n      var filter;\n      var roles;\n      options = Roles._normalizeOptions(options);\n\n      Roles._checkScopeName(options.scope);\n\n      options = Object.assign({\n        fullObjects: false,\n        onlyAssigned: false,\n        anyScope: false,\n        onlyScoped: false\n      }, options);\n\n      if (user && typeof user === 'object') {\n        id = user._id;\n      } else {\n        id = user;\n      }\n\n      if (!id) return [];\n      selector = {\n        'user._id': id\n      };\n      filter = {\n        fields: {\n          'inheritedRoles._id': 1\n        }\n      };\n\n      if (!options.anyScope) {\n        selector.scope = {\n          $in: [options.scope]\n        };\n\n        if (!options.onlyScoped) {\n          selector.scope.$in.push(null);\n        }\n      }\n\n      if (options.onlyAssigned) {\n        delete filter.fields['inheritedRoles._id'];\n        filter.fields['role._id'] = 1;\n      }\n\n      if (options.fullObjects) {\n        delete filter.fields;\n      }\n\n      roles = Meteor.roleAssignment.find(selector, filter).fetch();\n\n      if (options.fullObjects) {\n        return roles;\n      }\n\n      return [...new Set(roles.reduce((rev, current) => {\n        if (current.inheritedRoles) {\n          return rev.concat(current.inheritedRoles.map(r => r._id));\n        } else if (current.role) {\n          rev.push(current.role._id);\n        }\n\n        return rev;\n      }, []))];\n    },\n\n    /**\n     * Retrieve cursor of all existing roles.\n     *\n     * @method getAllRoles\n     * @param {Object} [queryOptions] Options which are passed directly\n     *                                through to `Meteor.roles.find(query, options)`.\n     * @return {Cursor} Cursor of existing roles.\n     * @static\n     */\n    getAllRoles: function (queryOptions) {\n      queryOptions = queryOptions || {\n        sort: {\n          _id: 1\n        }\n      };\n      return Meteor.roles.find({}, queryOptions);\n    },\n\n    /**\n     * Retrieve all users who are in target role.\n     *\n     * Options:\n     *\n     * @method getUsersInRole\n     * @param {Array|String} roles Name of role or an array of roles. If array, users\n     *                             returned will have at least one of the roles\n     *                             specified but need not have _all_ roles.\n     *                             Roles do not have to exist.\n     * @param {Object|String} [options] Options:\n     *   - `scope`: name of the scope to restrict roles to; user's global\n     *     roles will also be checked\n     *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n     *   - `onlyScoped`: if set, only roles in the specified scope are returned\n     *   - `queryOptions`: options which are passed directly\n     *     through to `Meteor.users.find(query, options)`\n     *\n     * Alternatively, it can be a scope name string.\n     * @param {Object} [queryOptions] Options which are passed directly\n     *                                through to `Meteor.users.find(query, options)`\n     * @return {Cursor} Cursor of users in roles.\n     * @static\n     */\n    getUsersInRole: function (roles, options, queryOptions) {\n      var ids;\n      ids = Roles.getUserAssignmentsForRole(roles, options).fetch().map(a => a.user._id);\n      return Meteor.users.find({\n        _id: {\n          $in: ids\n        }\n      }, options && options.queryOptions || queryOptions || {});\n    },\n\n    /**\n     * Retrieve all assignments of a user which are for the target role.\n     *\n     * Options:\n     *\n     * @method getUserAssignmentsForRole\n     * @param {Array|String} roles Name of role or an array of roles. If array, users\n     *                             returned will have at least one of the roles\n     *                             specified but need not have _all_ roles.\n     *                             Roles do not have to exist.\n     * @param {Object|String} [options] Options:\n     *   - `scope`: name of the scope to restrict roles to; user's global\n     *     roles will also be checked\n     *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n     *   - `queryOptions`: options which are passed directly\n     *     through to `Meteor.roleAssignment.find(query, options)`\n      * Alternatively, it can be a scope name string.\n     * @return {Cursor} Cursor of user assignments for roles.\n     * @static\n     */\n    getUserAssignmentsForRole: function (roles, options) {\n      options = Roles._normalizeOptions(options);\n      options = Object.assign({\n        anyScope: false,\n        queryOptions: {}\n      }, options);\n      return Roles._getUsersInRoleCursor(roles, options, options.queryOptions);\n    },\n\n    /**\n     * @method _getUsersInRoleCursor\n     * @param {Array|String} roles Name of role or an array of roles. If array, ids of users are\n     *                             returned which have at least one of the roles\n     *                             assigned but need not have _all_ roles.\n     *                             Roles do not have to exist.\n     * @param {Object|String} [options] Options:\n     *   - `scope`: name of the scope to restrict roles to; user's global\n     *     roles will also be checked\n     *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n     *\n     * Alternatively, it can be a scope name string.\n     * @param {Object} [filter] Options which are passed directly\n     *                                through to `Meteor.roleAssignment.find(query, options)`\n     * @return {Object} Cursor to the assignment documents\n     * @private\n     * @static\n     */\n    _getUsersInRoleCursor: function (roles, options, filter) {\n      var selector;\n      options = Roles._normalizeOptions(options);\n      options = Object.assign({\n        anyScope: false,\n        onlyScoped: false\n      }, options); // ensure array to simplify code\n\n      if (!Array.isArray(roles)) roles = [roles];\n\n      Roles._checkScopeName(options.scope);\n\n      filter = Object.assign({\n        fields: {\n          'user._id': 1\n        }\n      }, filter);\n      selector = {\n        'inheritedRoles._id': {\n          $in: roles\n        }\n      };\n\n      if (!options.anyScope) {\n        selector.scope = {\n          $in: [options.scope]\n        };\n\n        if (!options.onlyScoped) {\n          selector.scope.$in.push(null);\n        }\n      }\n\n      return Meteor.roleAssignment.find(selector, filter);\n    },\n\n    /**\n     * Deprecated. Use `getScopesForUser` instead.\n     *\n     * @method getGroupsForUser\n     * @static\n     * @deprecated\n     */\n    getGroupsForUser: function () {\n      if (!getGroupsForUserDeprecationWarning) {\n        getGroupsForUserDeprecationWarning = true;\n        console && console.warn('getGroupsForUser has been deprecated. Use getScopesForUser instead.');\n      }\n\n      return Roles.getScopesForUser(...arguments);\n    },\n\n    /**\n     * Retrieve users scopes, if any.\n     *\n     * @method getScopesForUser\n     * @param {String|Object} user User ID or an actual user object.\n     * @param {Array|String} [roles] Name of roles to restrict scopes to.\n     *\n     * @return {Array} Array of user's scopes, unsorted.\n     * @static\n     */\n    getScopesForUser: function (user, roles) {\n      var scopes;\n      var id;\n      if (roles && !Array.isArray(roles)) roles = [roles];\n\n      if (user && typeof user === 'object') {\n        id = user._id;\n      } else {\n        id = user;\n      }\n\n      if (!id) return [];\n      const selector = {\n        'user._id': id,\n        scope: {\n          $ne: null\n        }\n      };\n\n      if (roles) {\n        selector['inheritedRoles._id'] = {\n          $in: roles\n        };\n      }\n\n      scopes = Meteor.roleAssignment.find(selector, {\n        fields: {\n          scope: 1\n        }\n      }).fetch().map(obi => obi.scope);\n      return [...new Set(scopes)];\n    },\n\n    /**\n     * Rename a scope.\n     *\n     * Roles assigned with a given scope are changed to be under the new scope.\n     *\n     * @method renameScope\n     * @param {String} oldName Old name of a scope.\n     * @param {String} newName New name of a scope.\n     * @static\n     */\n    renameScope: function (oldName, newName) {\n      var count;\n\n      Roles._checkScopeName(oldName);\n\n      Roles._checkScopeName(newName);\n\n      if (oldName === newName) return;\n\n      do {\n        count = Meteor.roleAssignment.update({\n          scope: oldName\n        }, {\n          $set: {\n            scope: newName\n          }\n        }, {\n          multi: true\n        });\n      } while (count > 0);\n    },\n\n    /**\n     * Remove a scope.\n     *\n     * Roles assigned with a given scope are removed.\n     *\n     * @method removeScope\n     * @param {String} name The name of a scope.\n     * @static\n     */\n    removeScope: function (name) {\n      Roles._checkScopeName(name);\n\n      Meteor.roleAssignment.remove({\n        scope: name\n      });\n    },\n\n    /**\n     * Throw an exception if `roleName` is an invalid role name.\n     *\n     * @method _checkRoleName\n     * @param {String} roleName A role name to match against.\n     * @private\n     * @static\n     */\n    _checkRoleName: function (roleName) {\n      if (!roleName || typeof roleName !== 'string' || roleName.trim() !== roleName) {\n        throw new Error('Invalid role name \\'' + roleName + '\\'.');\n      }\n    },\n\n    /**\n     * Find out if a role is an ancestor of another role.\n     *\n     * WARNING: If you check this on the client, please make sure all roles are published.\n     *\n     * @method isParentOf\n     * @param {String} parentRoleName The role you want to research.\n     * @param {String} childRoleName The role you expect to be among the children of parentRoleName.\n     * @static\n     */\n    isParentOf: function (parentRoleName, childRoleName) {\n      if (parentRoleName === childRoleName) {\n        return true;\n      }\n\n      if (parentRoleName == null || childRoleName == null) {\n        return false;\n      }\n\n      Roles._checkRoleName(parentRoleName);\n\n      Roles._checkRoleName(childRoleName);\n\n      var rolesToCheck = [parentRoleName];\n\n      while (rolesToCheck.length !== 0) {\n        var roleName = rolesToCheck.pop();\n\n        if (roleName === childRoleName) {\n          return true;\n        }\n\n        var role = Meteor.roles.findOne({\n          _id: roleName\n        }); // This should not happen, but this is a problem to address at some other time.\n\n        if (!role) continue;\n        rolesToCheck = rolesToCheck.concat(role.children.map(r => r._id));\n      }\n\n      return false;\n    },\n\n    /**\n     * Normalize options.\n     *\n     * @method _normalizeOptions\n     * @param {Object} options Options to normalize.\n     * @return {Object} Normalized options.\n     * @private\n     * @static\n     */\n    _normalizeOptions: function (options) {\n      options = options === undefined ? {} : options;\n\n      if (options === null || typeof options === 'string') {\n        options = {\n          scope: options\n        };\n      }\n\n      options.scope = Roles._normalizeScopeName(options.scope);\n      return options;\n    },\n\n    /**\n     * Normalize scope name.\n     *\n     * @method _normalizeScopeName\n     * @param {String} scopeName A scope name to normalize.\n     * @return {String} Normalized scope name.\n     * @private\n     * @static\n     */\n    _normalizeScopeName: function (scopeName) {\n      // map undefined and null to null\n      if (scopeName == null) {\n        return null;\n      } else {\n        return scopeName;\n      }\n    },\n\n    /**\n     * Throw an exception if `scopeName` is an invalid scope name.\n     *\n     * @method _checkRoleName\n     * @param {String} scopeName A scope name to match against.\n     * @private\n     * @static\n     */\n    _checkScopeName: function (scopeName) {\n      if (scopeName === null) return;\n\n      if (!scopeName || typeof scopeName !== 'string' || scopeName.trim() !== scopeName) {\n        throw new Error('Invalid scope name \\'' + scopeName + '\\'.');\n      }\n    }\n  });\n}.call(this, module);\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"client\":{\"debug.js\":function module(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/alanning_roles/roles/client/debug.js                                                                       //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n/* global Roles, localStorage */\n// //////////////////////////////////////////////////////////\n// Debugging helpers\n//\n// Run this in your browser console to turn on debugging\n// for this package:\n//\n//   localstorage.setItem('Roles.debug', true)\n//\nRoles.debug = false;\n\ntry {\n  if (localStorage) {\n    var temp = localStorage.getItem('Roles.debug');\n\n    if (typeof temp !== 'undefined') {\n      Roles.debug = !!temp;\n    }\n  }\n} catch (ex) {// ignore: accessing localStorage when its disabled throws\n  // https://github.com/meteor/meteor/issues/5759\n}\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"uiHelpers.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/alanning_roles/roles/client/uiHelpers.js                                                                   //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n!function (module1) {\n  /* global Meteor, Roles, Match, Package */\n\n  /**\n   * Convenience functions for use on client.\n   *\n   * NOTE: You must restrict user actions on the server-side; any\n   * client-side checks are strictly for convenience and must not be\n   * trusted.\n   *\n   * @module UIHelpers\n   */\n  // //////////////////////////////////////////////////////////\n  // UI helpers\n  //\n  // Use a semi-private variable rather than declaring UI\n  // helpers directly so that we can unit test the helpers.\n  // XXX For some reason, the UI helpers are not registered\n  // before the tests run.\n  //\n  Roles._uiHelpers = {\n    /**\n     * UI helper to check if current user is in at least one\n     * of the target roles.  For use in client-side templates.\n     *\n     * @example\n     *     {{#if isInRole 'admin'}}\n     *     {{/if}}\n     *\n     *     {{#if isInRole 'editor,user'}}\n     *     {{/if}}\n     *\n     *     {{#if isInRole 'editor,user' 'scope1'}}\n     *     {{/if}}\n     *\n     * @method isInRole\n     * @param {String} role Name of role or comma-seperated list of roles.\n     * @param {String} [scope] Optional, name of scope to check.\n     * @return {Boolean} `true` if current user is in at least one of the target roles.\n     * @static\n     * @for UIHelpers\n     */\n    isInRole: function (role, scope) {\n      var user = Meteor.user();\n      var comma = (role || '').indexOf(',');\n      var roles;\n      if (!user) return false;\n      if (!Match.test(role, String)) return false;\n\n      if (comma !== -1) {\n        roles = role.split(',').reduce(function (memo, r) {\n          if (!r) {\n            return memo;\n          }\n\n          memo.push(r);\n          return memo;\n        }, []);\n      } else {\n        roles = [role];\n      }\n\n      if (Match.test(scope, String)) {\n        return Roles.userIsInRole(user, roles, scope);\n      }\n\n      return Roles.userIsInRole(user, roles);\n    }\n  }; // //////////////////////////////////////////////////////////\n  // Register UI helpers\n  //\n\n  if (Roles.debug && console.log) {\n    console.log('[roles] Roles.debug =', Roles.debug);\n  }\n\n  if (typeof Package.blaze !== 'undefined' && typeof Package.blaze.Blaze !== 'undefined' && typeof Package.blaze.Blaze.registerHelper === 'function') {\n    Object.entries(Roles._uiHelpers).forEach(_ref => {\n      let [name, func] = _ref;\n\n      if (Roles.debug && console.log) {\n        console.log('[roles] registering Blaze helper \\'' + name + '\\'');\n      }\n\n      Package.blaze.Blaze.registerHelper(name, func);\n    });\n  }\n}.call(this, module);\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"subscriptions.js\":function module(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/alanning_roles/roles/client/subscriptions.js                                                               //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n/* global Meteor, Roles, Tracker */\n\n/**\n * Subscription handle for the collection of all existing roles.\n *\n * @example\n *\n *     Roles.subscription.ready(); // true if roles have been loaded\n *\n * @property subscription\n * @type Object\n * @for Roles\n * @static\n */\nTracker.autorun(function () {\n  Roles.subscription = Meteor.subscribe('_roles');\n});\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}}}}},{\n  \"extensions\": [\n    \".js\",\n    \".json\",\n    \".css\"\n  ]\n});\n\nrequire(\"/node_modules/meteor/alanning:roles/roles/roles_common.js\");\nrequire(\"/node_modules/meteor/alanning:roles/roles/client/debug.js\");\nrequire(\"/node_modules/meteor/alanning:roles/roles/client/uiHelpers.js\");\nrequire(\"/node_modules/meteor/alanning:roles/roles/client/subscriptions.js\");\n\n/* Exports */\nPackage._define(\"alanning:roles\", {\n  Roles: Roles\n});\n\n})();\n","servePath":"/packages/alanning_roles.js","sourceMap":{"version":3,"sources":["packages/alanning:roles/roles/roles_common.js","packages/alanning:roles/roles/client/debug.js","packages/alanning:roles/roles/client/uiHelpers.js","packages/alanning:roles/roles/client/subscriptions.js"],"names":["Meteor","roles","Mongo","Collection","roleAssignment","Roles","getGroupsForUserDeprecationWarning","Object","assign","GLOBAL_GROUP","createRole","roleName","options","_checkRoleName","unlessExists","result","upsert","_id","$setOnInsert","children","insertedId","Error","deleteRole","inheritedRoles","remove","_getParentRoleNames","findOne","find","$in","fetch","forEach","r","update","$pull","_getInheritedRoleNames","$set","map","r2","multi","length","renameRole","oldName","newName","role","count","insert","addRolesToParent","rolesNames","parentName","Array","isArray","_addRoleToParent","includes","$ne","$push","$each","removeRolesFromParent","_removeRoleFromParent","fields","addUsersToRoles","users","id","_normalizeOptions","_checkScopeName","scope","ifExists","user","_addUserToRole","setUserRoles","anyScope","selector","userId","res","parentRoles","Set","parentRole","add","delete","nestedRoles","removeUsersFromRoles","_removeUserFromRole","userIsInRole","filter","some","limit","getRolesForUser","fullObjects","onlyAssigned","onlyScoped","push","reduce","rev","current","concat","getAllRoles","queryOptions","sort","getUsersInRole","ids","getUserAssignmentsForRole","a","_getUsersInRoleCursor","getGroupsForUser","console","warn","getScopesForUser","scopes","obi","renameScope","removeScope","name","trim","isParentOf","parentRoleName","childRoleName","rolesToCheck","pop","undefined","_normalizeScopeName","scopeName","debug","localStorage","temp","getItem","ex","_uiHelpers","isInRole","comma","indexOf","Match","test","String","split","memo","log","Package","blaze","Blaze","registerHelper","entries","func","Tracker","autorun","subscription","subscribe"],"mappings":"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","file":"/packages/alanning_roles.js","sourcesContent":["/* global Meteor, Roles, Mongo */\n\n/**\n * Provides functions related to user authorization. Compatible with built-in Meteor accounts packages.\n *\n * Roles are accessible throgh `Meteor.roles` collection and documents consist of:\n *  - `_id`: role name\n *  - `children`: list of subdocuments:\n *    - `_id`\n *\n * Children list elements are subdocuments so that they can be easier extended in the future or by plugins.\n *\n * Roles can have multiple parents and can be children (subroles) of multiple roles.\n *\n * Example: `{_id: 'admin', children: [{_id: 'editor'}]}`\n *\n * The assignment of a role to a user is stored in a collection, accessible through `Meteor.roleAssignment`.\n * It's documents consist of\n *  - `_id`: Internal MongoDB id\n *  - `role`: A role object which got assigned. Usually only contains the `_id` property\n *  - `user`: A user object, usually only contains the `_id` property\n *  - `scope`: scope name\n *  - `inheritedRoles`: A list of all the roles objects inherited by the assigned role.\n *\n * @module Roles\n */\nif (!Meteor.roles) {\n  Meteor.roles = new Mongo.Collection('roles')\n}\n\nif (!Meteor.roleAssignment) {\n  Meteor.roleAssignment = new Mongo.Collection('role-assignment')\n}\n\n/**\n * @class Roles\n */\nif (typeof Roles === 'undefined') {\n  Roles = {} // eslint-disable-line no-global-assign\n}\n\nvar getGroupsForUserDeprecationWarning = false\n\nObject.assign(Roles, {\n\n  /**\n   * Used as a global group (now scope) name. Not used anymore.\n   *\n   * @property GLOBAL_GROUP\n   * @static\n   * @deprecated\n   */\n  GLOBAL_GROUP: null,\n\n  /**\n   * Create a new role.\n   *\n   * @method createRole\n   * @param {String} roleName Name of role.\n   * @param {Object} [options] Options:\n   *   - `unlessExists`: if `true`, exception will not be thrown in the role already exists\n   * @return {String} ID of the new role or null.\n   * @static\n   */\n  createRole: function (roleName, options) {\n    Roles._checkRoleName(roleName)\n\n    options = Object.assign({\n      unlessExists: false\n    }, options)\n\n    var result = Meteor.roles.upsert({ _id: roleName }, { $setOnInsert: { children: [] } })\n\n    if (!result.insertedId) {\n      if (options.unlessExists) return null\n      throw new Error('Role \\'' + roleName + '\\' already exists.')\n    }\n\n    return result.insertedId\n  },\n\n  /**\n   * Delete an existing role.\n   *\n   * If the role is set for any user, it is automatically unset.\n   *\n   * @method deleteRole\n   * @param {String} roleName Name of role.\n   * @static\n   */\n  deleteRole: function (roleName) {\n    var roles\n    var inheritedRoles\n\n    Roles._checkRoleName(roleName)\n\n    // Remove all assignments\n    Meteor.roleAssignment.remove({\n      'role._id': roleName\n    })\n\n    do {\n      // For all roles who have it as a dependency ...\n      roles = Roles._getParentRoleNames(Meteor.roles.findOne({ _id: roleName }))\n\n      Meteor.roles.find({ _id: { $in: roles } }).fetch().forEach(r => {\n        Meteor.roles.update({\n          _id: r._id\n        }, {\n          $pull: {\n            children: {\n              _id: roleName\n            }\n          }\n        })\n\n        inheritedRoles = Roles._getInheritedRoleNames(Meteor.roles.findOne({ _id: r._id }))\n        Meteor.roleAssignment.update({\n          'role._id': r._id\n        }, {\n          $set: {\n            inheritedRoles: [r._id, ...inheritedRoles].map(r2 => ({ _id: r2 }))\n          }\n        }, { multi: true })\n      })\n    } while (roles.length > 0)\n\n    // And finally remove the role itself\n    Meteor.roles.remove({ _id: roleName })\n  },\n\n  /**\n   * Rename an existing role.\n   *\n   * @method renameRole\n   * @param {String} oldName Old name of a role.\n   * @param {String} newName New name of a role.\n   * @static\n   */\n  renameRole: function (oldName, newName) {\n    var role\n    var count\n\n    Roles._checkRoleName(oldName)\n    Roles._checkRoleName(newName)\n\n    if (oldName === newName) return\n\n    role = Meteor.roles.findOne({ _id: oldName })\n\n    if (!role) {\n      throw new Error('Role \\'' + oldName + '\\' does not exist.')\n    }\n\n    role._id = newName\n\n    Meteor.roles.insert(role)\n\n    do {\n      count = Meteor.roleAssignment.update({\n        'role._id': oldName\n      }, {\n        $set: {\n          'role._id': newName\n        }\n      }, { multi: true })\n    } while (count > 0)\n\n    do {\n      count = Meteor.roleAssignment.update({\n        'inheritedRoles._id': oldName\n      }, {\n        $set: {\n          'inheritedRoles.$._id': newName\n        }\n      }, { multi: true })\n    } while (count > 0)\n\n    do {\n      count = Meteor.roles.update({\n        'children._id': oldName\n      }, {\n        $set: {\n          'children.$._id': newName\n        }\n      }, { multi: true })\n    } while (count > 0)\n\n    Meteor.roles.remove({ _id: oldName })\n  },\n\n  /**\n   * Add role parent to roles.\n   *\n   * Previous parents are kept (role can have multiple parents). For users which have the\n   * parent role set, new subroles are added automatically.\n   *\n   * @method addRolesToParent\n   * @param {Array|String} rolesNames Name(s) of role(s).\n   * @param {String} parentName Name of parent role.\n   * @static\n   */\n  addRolesToParent: function (rolesNames, parentName) {\n    // ensure arrays\n    if (!Array.isArray(rolesNames)) rolesNames = [rolesNames]\n\n    rolesNames.forEach(function (roleName) {\n      Roles._addRoleToParent(roleName, parentName)\n    })\n  },\n\n  /**\n   * @method _addRoleToParent\n   * @param {String} roleName Name of role.\n   * @param {String} parentName Name of parent role.\n   * @private\n   * @static\n   */\n  _addRoleToParent: function (roleName, parentName) {\n    var role\n    var count\n\n    Roles._checkRoleName(roleName)\n    Roles._checkRoleName(parentName)\n\n    // query to get role's children\n    role = Meteor.roles.findOne({ _id: roleName })\n\n    if (!role) {\n      throw new Error('Role \\'' + roleName + '\\' does not exist.')\n    }\n\n    // detect cycles\n    if (Roles._getInheritedRoleNames(role).includes(parentName)) {\n      throw new Error('Roles \\'' + roleName + '\\' and \\'' + parentName + '\\' would form a cycle.')\n    }\n\n    count = Meteor.roles.update({\n      _id: parentName,\n      'children._id': {\n        $ne: role._id\n      }\n    }, {\n      $push: {\n        children: {\n          _id: role._id\n        }\n      }\n    })\n\n    // if there was no change, parent role might not exist, or role is\n    // already a subrole; in any case we do not have anything more to do\n    if (!count) return\n\n    Meteor.roleAssignment.update({\n      'inheritedRoles._id': parentName\n    }, {\n      $push: {\n        inheritedRoles: { $each: [role._id, ...Roles._getInheritedRoleNames(role)].map(r => ({ _id: r })) }\n      }\n    }, { multi: true })\n  },\n\n  /**\n   * Remove role parent from roles.\n   *\n   * Other parents are kept (role can have multiple parents). For users which have the\n   * parent role set, removed subrole is removed automatically.\n   *\n   * @method removeRolesFromParent\n   * @param {Array|String} rolesNames Name(s) of role(s).\n   * @param {String} parentName Name of parent role.\n   * @static\n   */\n  removeRolesFromParent: function (rolesNames, parentName) {\n    // ensure arrays\n    if (!Array.isArray(rolesNames)) rolesNames = [rolesNames]\n\n    rolesNames.forEach(function (roleName) {\n      Roles._removeRoleFromParent(roleName, parentName)\n    })\n  },\n\n  /**\n   * @method _removeRoleFromParent\n   * @param {String} roleName Name of role.\n   * @param {String} parentName Name of parent role.\n   * @private\n   * @static\n   */\n  _removeRoleFromParent: function (roleName, parentName) {\n    Roles._checkRoleName(roleName)\n    Roles._checkRoleName(parentName)\n\n    // check for role existence\n    // this would not really be needed, but we are trying to match addRolesToParent\n    let role = Meteor.roles.findOne({ _id: roleName }, { fields: { _id: 1 } })\n\n    if (!role) {\n      throw new Error('Role \\'' + roleName + '\\' does not exist.')\n    }\n\n    const count = Meteor.roles.update({\n      _id: parentName\n    }, {\n      $pull: {\n        children: {\n          _id: role._id\n        }\n      }\n    })\n\n    // if there was no change, parent role might not exist, or role was\n    // already not a subrole; in any case we do not have anything more to do\n    if (!count) return\n\n    // For all roles who have had it as a dependency ...\n    const roles = [...Roles._getParentRoleNames(Meteor.roles.findOne({ _id: parentName })), parentName]\n\n    Meteor.roles.find({ _id: { $in: roles } }).fetch().forEach(r => {\n      const inheritedRoles = Roles._getInheritedRoleNames(Meteor.roles.findOne({ _id: r._id }))\n      Meteor.roleAssignment.update({\n        'role._id': r._id,\n        'inheritedRoles._id': role._id\n      }, {\n        $set: {\n          inheritedRoles: [r._id, ...inheritedRoles].map(r2 => ({ _id: r2 }))\n        }\n      }, { multi: true })\n    })\n  },\n\n  /**\n   * Add users to roles.\n   *\n   * Adds roles to existing roles for each user.\n   *\n   * @example\n   *     Roles.addUsersToRoles(userId, 'admin')\n   *     Roles.addUsersToRoles(userId, ['view-secrets'], 'example.com')\n   *     Roles.addUsersToRoles([user1, user2], ['user','editor'])\n   *     Roles.addUsersToRoles([user1, user2], ['glorious-admin', 'perform-action'], 'example.org')\n   *\n   * @method addUsersToRoles\n   * @param {Array|String} users User ID(s) or object(s) with an `_id` field.\n   * @param {Array|String} roles Name(s) of roles to add users to. Roles have to exist.\n   * @param {Object|String} [options] Options:\n   *   - `scope`: name of the scope, or `null` for the global role\n   *   - `ifExists`: if `true`, do not throw an exception if the role does not exist\n   *\n   * Alternatively, it can be a scope name string.\n   * @static\n   */\n  addUsersToRoles: function (users, roles, options) {\n    var id\n\n    if (!users) throw new Error('Missing \\'users\\' param.')\n    if (!roles) throw new Error('Missing \\'roles\\' param.')\n\n    options = Roles._normalizeOptions(options)\n\n    // ensure arrays\n    if (!Array.isArray(users)) users = [users]\n    if (!Array.isArray(roles)) roles = [roles]\n\n    Roles._checkScopeName(options.scope)\n\n    options = Object.assign({\n      ifExists: false\n    }, options)\n\n    users.forEach(function (user) {\n      if (typeof user === 'object') {\n        id = user._id\n      } else {\n        id = user\n      }\n\n      roles.forEach(function (role) {\n        Roles._addUserToRole(id, role, options)\n      })\n    })\n  },\n\n  /**\n   * Set users' roles.\n   *\n   * Replaces all existing roles with a new set of roles.\n   *\n   * @example\n   *     Roles.setUserRoles(userId, 'admin')\n   *     Roles.setUserRoles(userId, ['view-secrets'], 'example.com')\n   *     Roles.setUserRoles([user1, user2], ['user','editor'])\n   *     Roles.setUserRoles([user1, user2], ['glorious-admin', 'perform-action'], 'example.org')\n   *\n   * @method setUserRoles\n   * @param {Array|String} users User ID(s) or object(s) with an `_id` field.\n   * @param {Array|String} roles Name(s) of roles to add users to. Roles have to exist.\n   * @param {Object|String} [options] Options:\n   *   - `scope`: name of the scope, or `null` for the global role\n   *   - `anyScope`: if `true`, remove all roles the user has, of any scope, if `false`, only the one in the same scope\n   *   - `ifExists`: if `true`, do not throw an exception if the role does not exist\n   *\n   * Alternatively, it can be a scope name string.\n   * @static\n   */\n  setUserRoles: function (users, roles, options) {\n    var id\n\n    if (!users) throw new Error('Missing \\'users\\' param.')\n    if (!roles) throw new Error('Missing \\'roles\\' param.')\n\n    options = Roles._normalizeOptions(options)\n\n    // ensure arrays\n    if (!Array.isArray(users)) users = [users]\n    if (!Array.isArray(roles)) roles = [roles]\n\n    Roles._checkScopeName(options.scope)\n\n    options = Object.assign({\n      ifExists: false,\n      anyScope: false\n    }, options)\n\n    users.forEach(function (user) {\n      if (typeof user === 'object') {\n        id = user._id\n      } else {\n        id = user\n      }\n      // we first clear all roles for the user\n      const selector = { 'user._id': id }\n      if (!options.anyScope) {\n        selector.scope = options.scope\n      }\n\n      Meteor.roleAssignment.remove(selector)\n\n      // and then add all\n      roles.forEach(function (role) {\n        Roles._addUserToRole(id, role, options)\n      })\n    })\n  },\n\n  /**\n   * Add one user to one role.\n   *\n   * @method _addUserToRole\n   * @param {String} userId The user ID.\n   * @param {String} roleName Name of the role to add the user to. The role have to exist.\n   * @param {Object} options Options:\n   *   - `scope`: name of the scope, or `null` for the global role\n   *   - `ifExists`: if `true`, do not throw an exception if the role does not exist\n   * @private\n   * @static\n   */\n  _addUserToRole: function (userId, roleName, options) {\n    Roles._checkRoleName(roleName)\n    Roles._checkScopeName(options.scope)\n\n    if (!userId) {\n      return\n    }\n\n    const role = Meteor.roles.findOne({ _id: roleName }, { fields: { children: 1 } })\n\n    if (!role) {\n      if (options.ifExists) {\n        return []\n      } else {\n        throw new Error('Role \\'' + roleName + '\\' does not exist.')\n      }\n    }\n\n    // This might create duplicates, because we don't have a unique index, but that's all right. In case there are two, withdrawing the role will effectively kill them both.\n    const res = Meteor.roleAssignment.upsert({\n      'user._id': userId,\n      'role._id': roleName,\n      scope: options.scope\n    }, {\n      $setOnInsert: {\n        user: { _id: userId },\n        role: { _id: roleName },\n        scope: options.scope\n      }\n    })\n\n    if (res.insertedId) {\n      Meteor.roleAssignment.update({ _id: res.insertedId }, {\n        $set: {\n          inheritedRoles: [roleName, ...Roles._getInheritedRoleNames(role)].map(r => ({ _id: r }))\n        }\n      })\n    }\n\n    return res\n  },\n\n  /**\n   * Returns an array of role names the given role name is a child of.\n   *\n   * @example\n   *     Roles._getParentRoleNames({ _id: 'admin', children; [] })\n   *\n   * @method _getParentRoleNames\n   * @param {object} role The role object\n   * @private\n   * @static\n   */\n  _getParentRoleNames: function (role) {\n    var parentRoles\n\n    if (!role) {\n      return []\n    }\n\n    parentRoles = new Set([role._id])\n\n    parentRoles.forEach(roleName => {\n      Meteor.roles.find({ 'children._id': roleName }).fetch().forEach(parentRole => {\n        parentRoles.add(parentRole._id)\n      })\n    })\n\n    parentRoles.delete(role._id)\n\n    return [...parentRoles]\n  },\n\n  /**\n   * Returns an array of role names the given role name is a parent of.\n   *\n   * @example\n   *     Roles._getInheritedRoleNames({ _id: 'admin', children; [] })\n   *\n   * @method _getInheritedRoleNames\n   * @param {object} role The role object\n   * @private\n   * @static\n   */\n  _getInheritedRoleNames: function (role) {\n    const inheritedRoles = new Set()\n    const nestedRoles = new Set([role])\n\n    nestedRoles.forEach(r => {\n      const roles = Meteor.roles.find({ _id: { $in: r.children.map(r => r._id) } }, { fields: { children: 1 } }).fetch()\n\n      roles.forEach(r2 => {\n        inheritedRoles.add(r2._id)\n        nestedRoles.add(r2)\n      })\n    })\n\n    return [...inheritedRoles]\n  },\n\n  /**\n   * Remove users from assigned roles.\n   *\n   * @example\n   *     Roles.removeUsersFromRoles(userId, 'admin')\n   *     Roles.removeUsersFromRoles([userId, user2], ['editor'])\n   *     Roles.removeUsersFromRoles(userId, ['user'], 'group1')\n   *\n   * @method removeUsersFromRoles\n   * @param {Array|String} users User ID(s) or object(s) with an `_id` field.\n   * @param {Array|String} roles Name(s) of roles to remove users from. Roles have to exist.\n   * @param {Object|String} [options] Options:\n   *   - `scope`: name of the scope, or `null` for the global role\n   *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n   *\n   * Alternatively, it can be a scope name string.\n   * @static\n   */\n  removeUsersFromRoles: function (users, roles, options) {\n    if (!users) throw new Error('Missing \\'users\\' param.')\n    if (!roles) throw new Error('Missing \\'roles\\' param.')\n\n    options = Roles._normalizeOptions(options)\n\n    // ensure arrays\n    if (!Array.isArray(users)) users = [users]\n    if (!Array.isArray(roles)) roles = [roles]\n\n    Roles._checkScopeName(options.scope)\n\n    users.forEach(function (user) {\n      if (!user) return\n\n      roles.forEach(function (role) {\n        let id\n        if (typeof user === 'object') {\n          id = user._id\n        } else {\n          id = user\n        }\n\n        Roles._removeUserFromRole(id, role, options)\n      })\n    })\n  },\n\n  /**\n   * Remove one user from one role.\n   *\n   * @method _removeUserFromRole\n   * @param {String} userId The user ID.\n   * @param {String} roleName Name of the role to add the user to. The role have to exist.\n   * @param {Object} options Options:\n   *   - `scope`: name of the scope, or `null` for the global role\n   *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n   * @private\n   * @static\n   */\n  _removeUserFromRole: function (userId, roleName, options) {\n    Roles._checkRoleName(roleName)\n    Roles._checkScopeName(options.scope)\n\n    if (!userId) return\n\n    const selector = {\n      'user._id': userId,\n      'role._id': roleName\n    }\n\n    if (!options.anyScope) {\n      selector.scope = options.scope\n    }\n\n    Meteor.roleAssignment.remove(selector)\n  },\n\n  /**\n   * Check if user has specified roles.\n   *\n   * @example\n   *     // global roles\n   *     Roles.userIsInRole(user, 'admin')\n   *     Roles.userIsInRole(user, ['admin','editor'])\n   *     Roles.userIsInRole(userId, 'admin')\n   *     Roles.userIsInRole(userId, ['admin','editor'])\n   *\n   *     // scope roles (global roles are still checked)\n   *     Roles.userIsInRole(user, 'admin', 'group1')\n   *     Roles.userIsInRole(userId, ['admin','editor'], 'group1')\n   *     Roles.userIsInRole(userId, ['admin','editor'], {scope: 'group1'})\n   *\n   * @method userIsInRole\n   * @param {String|Object} user User ID or an actual user object.\n   * @param {Array|String} roles Name of role or an array of roles to check against. If array,\n   *                             will return `true` if user is in _any_ role.\n   *                             Roles do not have to exist.\n   * @param {Object|String} [options] Options:\n   *   - `scope`: name of the scope; if supplied, limits check to just that scope\n   *     the user's global roles will always be checked whether scope is specified or not\n   *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n   *\n   * Alternatively, it can be a scope name string.\n   * @return {Boolean} `true` if user is in _any_ of the target roles\n   * @static\n   */\n  userIsInRole: function (user, roles, options) {\n    var id\n    var selector\n\n    options = Roles._normalizeOptions(options)\n\n    // ensure array to simplify code\n    if (!Array.isArray(roles)) roles = [roles]\n\n    roles = roles.filter(r => r != null)\n\n    if (!roles.length) return false\n\n    Roles._checkScopeName(options.scope)\n\n    options = Object.assign({\n      anyScope: false\n    }, options)\n\n    if (user && typeof user === 'object') {\n      id = user._id\n    } else {\n      id = user\n    }\n\n    if (!id) return false\n    if (typeof id !== 'string') return false\n\n    selector = {\n      'user._id': id\n    }\n\n    if (!options.anyScope) {\n      selector.scope = { $in: [options.scope, null] }\n    }\n\n    return roles.some((roleName) => {\n      selector['inheritedRoles._id'] = roleName\n\n      return Meteor.roleAssignment.find(selector, { limit: 1 }).count() > 0\n    })\n  },\n\n  /**\n   * Retrieve user's roles.\n   *\n   * @method getRolesForUser\n   * @param {String|Object} user User ID or an actual user object.\n   * @param {Object|String} [options] Options:\n   *   - `scope`: name of scope to provide roles for; if not specified, global roles are returned\n   *   - `anyScope`: if set, role can be in any scope (`scope` and `onlyAssigned` options are ignored)\n   *   - `onlyScoped`: if set, only roles in the specified scope are returned\n   *   - `onlyAssigned`: return only assigned roles and not automatically inferred (like subroles)\n   *   - `fullObjects`: return full roles objects (`true`) or just names (`false`) (`onlyAssigned` option is ignored) (default `false`)\n   *     If you have a use-case for this option, please file a feature-request. You shouldn't need to use it as it's\n   *     result strongly dependant on the internal data structure of this plugin.\n   *\n   * Alternatively, it can be a scope name string.\n   * @return {Array} Array of user's roles, unsorted.\n   * @static\n   */\n  getRolesForUser: function (user, options) {\n    var id\n    var selector\n    var filter\n    var roles\n\n    options = Roles._normalizeOptions(options)\n\n    Roles._checkScopeName(options.scope)\n\n    options = Object.assign({\n      fullObjects: false,\n      onlyAssigned: false,\n      anyScope: false,\n      onlyScoped: false\n    }, options)\n\n    if (user && typeof user === 'object') {\n      id = user._id\n    } else {\n      id = user\n    }\n\n    if (!id) return []\n\n    selector = {\n      'user._id': id\n    }\n\n    filter = {\n      fields: { 'inheritedRoles._id': 1 }\n    }\n\n    if (!options.anyScope) {\n      selector.scope = { $in: [options.scope] }\n\n      if (!options.onlyScoped) {\n        selector.scope.$in.push(null)\n      }\n    }\n\n    if (options.onlyAssigned) {\n      delete filter.fields['inheritedRoles._id']\n      filter.fields['role._id'] = 1\n    }\n\n    if (options.fullObjects) {\n      delete filter.fields\n    }\n\n    roles = Meteor.roleAssignment.find(selector, filter).fetch()\n\n    if (options.fullObjects) {\n      return roles\n    }\n\n    return [...new Set(roles.reduce((rev, current) => {\n      if (current.inheritedRoles) {\n        return rev.concat(current.inheritedRoles.map(r => r._id))\n      } else if (current.role) {\n        rev.push(current.role._id)\n      }\n      return rev\n    }, []))]\n  },\n\n  /**\n   * Retrieve cursor of all existing roles.\n   *\n   * @method getAllRoles\n   * @param {Object} [queryOptions] Options which are passed directly\n   *                                through to `Meteor.roles.find(query, options)`.\n   * @return {Cursor} Cursor of existing roles.\n   * @static\n   */\n  getAllRoles: function (queryOptions) {\n    queryOptions = queryOptions || { sort: { _id: 1 } }\n\n    return Meteor.roles.find({}, queryOptions)\n  },\n\n  /**\n   * Retrieve all users who are in target role.\n   *\n   * Options:\n   *\n   * @method getUsersInRole\n   * @param {Array|String} roles Name of role or an array of roles. If array, users\n   *                             returned will have at least one of the roles\n   *                             specified but need not have _all_ roles.\n   *                             Roles do not have to exist.\n   * @param {Object|String} [options] Options:\n   *   - `scope`: name of the scope to restrict roles to; user's global\n   *     roles will also be checked\n   *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n   *   - `onlyScoped`: if set, only roles in the specified scope are returned\n   *   - `queryOptions`: options which are passed directly\n   *     through to `Meteor.users.find(query, options)`\n   *\n   * Alternatively, it can be a scope name string.\n   * @param {Object} [queryOptions] Options which are passed directly\n   *                                through to `Meteor.users.find(query, options)`\n   * @return {Cursor} Cursor of users in roles.\n   * @static\n   */\n  getUsersInRole: function (roles, options, queryOptions) {\n    var ids\n\n    ids = Roles.getUserAssignmentsForRole(roles, options).fetch().map(a => a.user._id)\n\n    return Meteor.users.find({ _id: { $in: ids } }, ((options && options.queryOptions) || queryOptions) || {})\n  },\n\n  /**\n   * Retrieve all assignments of a user which are for the target role.\n   *\n   * Options:\n   *\n   * @method getUserAssignmentsForRole\n   * @param {Array|String} roles Name of role or an array of roles. If array, users\n   *                             returned will have at least one of the roles\n   *                             specified but need not have _all_ roles.\n   *                             Roles do not have to exist.\n   * @param {Object|String} [options] Options:\n   *   - `scope`: name of the scope to restrict roles to; user's global\n   *     roles will also be checked\n   *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n   *   - `queryOptions`: options which are passed directly\n   *     through to `Meteor.roleAssignment.find(query, options)`\n\n   * Alternatively, it can be a scope name string.\n   * @return {Cursor} Cursor of user assignments for roles.\n   * @static\n   */\n  getUserAssignmentsForRole: function (roles, options) {\n    options = Roles._normalizeOptions(options)\n\n    options = Object.assign({\n      anyScope: false,\n      queryOptions: {}\n    }, options)\n\n    return Roles._getUsersInRoleCursor(roles, options, options.queryOptions)\n  },\n\n  /**\n   * @method _getUsersInRoleCursor\n   * @param {Array|String} roles Name of role or an array of roles. If array, ids of users are\n   *                             returned which have at least one of the roles\n   *                             assigned but need not have _all_ roles.\n   *                             Roles do not have to exist.\n   * @param {Object|String} [options] Options:\n   *   - `scope`: name of the scope to restrict roles to; user's global\n   *     roles will also be checked\n   *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n   *\n   * Alternatively, it can be a scope name string.\n   * @param {Object} [filter] Options which are passed directly\n   *                                through to `Meteor.roleAssignment.find(query, options)`\n   * @return {Object} Cursor to the assignment documents\n   * @private\n   * @static\n   */\n  _getUsersInRoleCursor: function (roles, options, filter) {\n    var selector\n\n    options = Roles._normalizeOptions(options)\n\n    options = Object.assign({\n      anyScope: false,\n      onlyScoped: false\n    }, options)\n\n    // ensure array to simplify code\n    if (!Array.isArray(roles)) roles = [roles]\n\n    Roles._checkScopeName(options.scope)\n\n    filter = Object.assign({\n      fields: { 'user._id': 1 }\n    }, filter)\n\n    selector = {\n      'inheritedRoles._id': { $in: roles }\n    }\n\n    if (!options.anyScope) {\n      selector.scope = { $in: [options.scope] }\n\n      if (!options.onlyScoped) {\n        selector.scope.$in.push(null)\n      }\n    }\n\n    return Meteor.roleAssignment.find(selector, filter)\n  },\n\n  /**\n   * Deprecated. Use `getScopesForUser` instead.\n   *\n   * @method getGroupsForUser\n   * @static\n   * @deprecated\n   */\n  getGroupsForUser: function (...args) {\n    if (!getGroupsForUserDeprecationWarning) {\n      getGroupsForUserDeprecationWarning = true\n      console && console.warn('getGroupsForUser has been deprecated. Use getScopesForUser instead.')\n    }\n\n    return Roles.getScopesForUser(...args)\n  },\n\n  /**\n   * Retrieve users scopes, if any.\n   *\n   * @method getScopesForUser\n   * @param {String|Object} user User ID or an actual user object.\n   * @param {Array|String} [roles] Name of roles to restrict scopes to.\n   *\n   * @return {Array} Array of user's scopes, unsorted.\n   * @static\n   */\n  getScopesForUser: function (user, roles) {\n    var scopes\n    var id\n\n    if (roles && !Array.isArray(roles)) roles = [roles]\n\n    if (user && typeof user === 'object') {\n      id = user._id\n    } else {\n      id = user\n    }\n\n    if (!id) return []\n\n    const selector = {\n      'user._id': id,\n      scope: { $ne: null }\n    }\n\n    if (roles) {\n      selector['inheritedRoles._id'] = { $in: roles }\n    }\n\n    scopes = Meteor.roleAssignment.find(selector, { fields: { scope: 1 } }).fetch().map(obi => obi.scope)\n\n    return [...new Set(scopes)]\n  },\n\n  /**\n   * Rename a scope.\n   *\n   * Roles assigned with a given scope are changed to be under the new scope.\n   *\n   * @method renameScope\n   * @param {String} oldName Old name of a scope.\n   * @param {String} newName New name of a scope.\n   * @static\n   */\n  renameScope: function (oldName, newName) {\n    var count\n\n    Roles._checkScopeName(oldName)\n    Roles._checkScopeName(newName)\n\n    if (oldName === newName) return\n\n    do {\n      count = Meteor.roleAssignment.update({\n        scope: oldName\n      }, {\n        $set: {\n          scope: newName\n        }\n      }, { multi: true })\n    } while (count > 0)\n  },\n\n  /**\n   * Remove a scope.\n   *\n   * Roles assigned with a given scope are removed.\n   *\n   * @method removeScope\n   * @param {String} name The name of a scope.\n   * @static\n   */\n  removeScope: function (name) {\n    Roles._checkScopeName(name)\n\n    Meteor.roleAssignment.remove({ scope: name })\n  },\n\n  /**\n   * Throw an exception if `roleName` is an invalid role name.\n   *\n   * @method _checkRoleName\n   * @param {String} roleName A role name to match against.\n   * @private\n   * @static\n   */\n  _checkRoleName: function (roleName) {\n    if (!roleName || typeof roleName !== 'string' || roleName.trim() !== roleName) {\n      throw new Error('Invalid role name \\'' + roleName + '\\'.')\n    }\n  },\n\n  /**\n   * Find out if a role is an ancestor of another role.\n   *\n   * WARNING: If you check this on the client, please make sure all roles are published.\n   *\n   * @method isParentOf\n   * @param {String} parentRoleName The role you want to research.\n   * @param {String} childRoleName The role you expect to be among the children of parentRoleName.\n   * @static\n   */\n  isParentOf: function (parentRoleName, childRoleName) {\n    if (parentRoleName === childRoleName) {\n      return true\n    }\n\n    if (parentRoleName == null || childRoleName == null) {\n      return false\n    }\n\n    Roles._checkRoleName(parentRoleName)\n    Roles._checkRoleName(childRoleName)\n\n    var rolesToCheck = [parentRoleName]\n    while (rolesToCheck.length !== 0) {\n      var roleName = rolesToCheck.pop()\n\n      if (roleName === childRoleName) {\n        return true\n      }\n\n      var role = Meteor.roles.findOne({ _id: roleName })\n\n      // This should not happen, but this is a problem to address at some other time.\n      if (!role) continue\n\n      rolesToCheck = rolesToCheck.concat(role.children.map(r => r._id))\n    }\n\n    return false\n  },\n\n  /**\n   * Normalize options.\n   *\n   * @method _normalizeOptions\n   * @param {Object} options Options to normalize.\n   * @return {Object} Normalized options.\n   * @private\n   * @static\n   */\n  _normalizeOptions: function (options) {\n    options = options === undefined ? {} : options\n\n    if (options === null || typeof options === 'string') {\n      options = { scope: options }\n    }\n\n    options.scope = Roles._normalizeScopeName(options.scope)\n\n    return options\n  },\n\n  /**\n   * Normalize scope name.\n   *\n   * @method _normalizeScopeName\n   * @param {String} scopeName A scope name to normalize.\n   * @return {String} Normalized scope name.\n   * @private\n   * @static\n   */\n  _normalizeScopeName: function (scopeName) {\n    // map undefined and null to null\n    if (scopeName == null) {\n      return null\n    } else {\n      return scopeName\n    }\n  },\n\n  /**\n   * Throw an exception if `scopeName` is an invalid scope name.\n   *\n   * @method _checkRoleName\n   * @param {String} scopeName A scope name to match against.\n   * @private\n   * @static\n   */\n  _checkScopeName: function (scopeName) {\n    if (scopeName === null) return\n\n    if (!scopeName || typeof scopeName !== 'string' || scopeName.trim() !== scopeName) {\n      throw new Error('Invalid scope name \\'' + scopeName + '\\'.')\n    }\n  }\n})\n","/* global Roles, localStorage */\n\n// //////////////////////////////////////////////////////////\n// Debugging helpers\n//\n// Run this in your browser console to turn on debugging\n// for this package:\n//\n//   localstorage.setItem('Roles.debug', true)\n//\n\nRoles.debug = false\n\ntry {\n  if (localStorage) {\n    var temp = localStorage.getItem('Roles.debug')\n\n    if (typeof temp !== 'undefined') {\n      Roles.debug = !!temp\n    }\n  }\n} catch (ex) {\n  // ignore: accessing localStorage when its disabled throws\n  // https://github.com/meteor/meteor/issues/5759\n}\n","/* global Meteor, Roles, Match, Package */\n\n/**\n * Convenience functions for use on client.\n *\n * NOTE: You must restrict user actions on the server-side; any\n * client-side checks are strictly for convenience and must not be\n * trusted.\n *\n * @module UIHelpers\n */\n\n// //////////////////////////////////////////////////////////\n// UI helpers\n//\n// Use a semi-private variable rather than declaring UI\n// helpers directly so that we can unit test the helpers.\n// XXX For some reason, the UI helpers are not registered\n// before the tests run.\n//\nRoles._uiHelpers = {\n\n  /**\n   * UI helper to check if current user is in at least one\n   * of the target roles.  For use in client-side templates.\n   *\n   * @example\n   *     {{#if isInRole 'admin'}}\n   *     {{/if}}\n   *\n   *     {{#if isInRole 'editor,user'}}\n   *     {{/if}}\n   *\n   *     {{#if isInRole 'editor,user' 'scope1'}}\n   *     {{/if}}\n   *\n   * @method isInRole\n   * @param {String} role Name of role or comma-seperated list of roles.\n   * @param {String} [scope] Optional, name of scope to check.\n   * @return {Boolean} `true` if current user is in at least one of the target roles.\n   * @static\n   * @for UIHelpers\n   */\n  isInRole: function (role, scope) {\n    var user = Meteor.user()\n    var comma = (role || '').indexOf(',')\n    var roles\n\n    if (!user) return false\n    if (!Match.test(role, String)) return false\n\n    if (comma !== -1) {\n      roles = role.split(',').reduce(function (memo, r) {\n        if (!r) {\n          return memo\n        }\n        memo.push(r)\n        return memo\n      }, [])\n    } else {\n      roles = [role]\n    }\n\n    if (Match.test(scope, String)) {\n      return Roles.userIsInRole(user, roles, scope)\n    }\n\n    return Roles.userIsInRole(user, roles)\n  }\n}\n\n// //////////////////////////////////////////////////////////\n// Register UI helpers\n//\n\nif (Roles.debug && console.log) {\n  console.log('[roles] Roles.debug =', Roles.debug)\n}\n\nif (typeof Package.blaze !== 'undefined' &&\n    typeof Package.blaze.Blaze !== 'undefined' &&\n    typeof Package.blaze.Blaze.registerHelper === 'function') {\n  Object.entries(Roles._uiHelpers).forEach(([name, func]) => {\n    if (Roles.debug && console.log) {\n      console.log('[roles] registering Blaze helper \\'' + name + '\\'')\n    }\n    Package.blaze.Blaze.registerHelper(name, func)\n  })\n}\n","/* global Meteor, Roles, Tracker */\n\n/**\n * Subscription handle for the collection of all existing roles.\n *\n * @example\n *\n *     Roles.subscription.ready(); // true if roles have been loaded\n *\n * @property subscription\n * @type Object\n * @for Roles\n * @static\n */\n\nTracker.autorun(function () {\n  Roles.subscription = Meteor.subscribe('_roles')\n})\n"]}}]