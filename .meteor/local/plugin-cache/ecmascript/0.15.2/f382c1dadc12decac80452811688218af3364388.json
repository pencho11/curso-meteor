{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"C:\\Users\\RUBEN\\Desktop\\meteor-vue\\packages\\spacebars-compiler\\optimizer.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.windows.x86_64"},"sourceFileName":"packages/spacebars-compiler/optimizer.js","filename":"C:\\Users\\RUBEN\\Desktop\\meteor-vue\\packages\\spacebars-compiler\\optimizer.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"C:\\Users\\RUBEN\\Desktop\\meteor-vue","root":"C:\\Users\\RUBEN\\Desktop\\meteor-vue","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true}},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.14.0","helpers":true,"useESModules":false,"corejs":false}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":true,"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_verified":true},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}}],"presets":[],"generatorOpts":{"filename":"C:\\Users\\RUBEN\\Desktop\\meteor-vue\\packages\\spacebars-compiler\\optimizer.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/spacebars-compiler/optimizer.js"}},"code":"module.export({\n  toRaw: () => toRaw,\n  TreeTransformer: () => TreeTransformer,\n  optimize: () => optimize\n});\nlet HTMLTools;\nmodule.link(\"meteor/html-tools\", {\n  HTMLTools(v) {\n    HTMLTools = v;\n  }\n\n}, 0);\nlet HTML;\nmodule.link(\"meteor/htmljs\", {\n  HTML(v) {\n    HTML = v;\n  }\n\n}, 1);\n\n// Optimize parts of an HTMLjs tree into raw HTML strings when they don't\n// contain template tags.\nvar constant = function (value) {\n  return function () {\n    return value;\n  };\n};\n\nvar OPTIMIZABLE = {\n  NONE: 0,\n  PARTS: 1,\n  FULL: 2\n}; // We can only turn content into an HTML string if it contains no template\n// tags and no \"tricky\" HTML tags.  If we can optimize the entire content\n// into a string, we return OPTIMIZABLE.FULL.  If the we are given an\n// unoptimizable node, we return OPTIMIZABLE.NONE.  If we are given a tree\n// that contains an unoptimizable node somewhere, we return OPTIMIZABLE.PARTS.\n//\n// For example, we always create SVG elements programmatically, since SVG\n// doesn't have innerHTML.  If we are given an SVG element, we return NONE.\n// However, if we are given a big tree that contains SVG somewhere, we\n// return PARTS so that the optimizer can descend into the tree and optimize\n// other parts of it.\n\nvar CanOptimizeVisitor = HTML.Visitor.extend();\nCanOptimizeVisitor.def({\n  visitNull: constant(OPTIMIZABLE.FULL),\n  visitPrimitive: constant(OPTIMIZABLE.FULL),\n  visitComment: constant(OPTIMIZABLE.FULL),\n  visitCharRef: constant(OPTIMIZABLE.FULL),\n  visitRaw: constant(OPTIMIZABLE.FULL),\n  visitObject: constant(OPTIMIZABLE.NONE),\n  visitFunction: constant(OPTIMIZABLE.NONE),\n  visitArray: function (x) {\n    for (var i = 0; i < x.length; i++) if (this.visit(x[i]) !== OPTIMIZABLE.FULL) return OPTIMIZABLE.PARTS;\n\n    return OPTIMIZABLE.FULL;\n  },\n  visitTag: function (tag) {\n    var tagName = tag.tagName;\n\n    if (tagName === 'textarea') {\n      // optimizing into a TEXTAREA's RCDATA would require being a little\n      // more clever.\n      return OPTIMIZABLE.NONE;\n    } else if (tagName === 'script') {\n      // script tags don't work when rendered from strings\n      return OPTIMIZABLE.NONE;\n    } else if (!(HTML.isKnownElement(tagName) && !HTML.isKnownSVGElement(tagName))) {\n      // foreign elements like SVG can't be stringified for innerHTML.\n      return OPTIMIZABLE.NONE;\n    } else if (tagName === 'table') {\n      // Avoid ever producing HTML containing `<table><tr>...`, because the\n      // browser will insert a TBODY.  If we just `createElement(\"table\")` and\n      // `createElement(\"tr\")`, on the other hand, no TBODY is necessary\n      // (assuming IE 8+).\n      return OPTIMIZABLE.PARTS;\n    } else if (tagName === 'tr') {\n      return OPTIMIZABLE.PARTS;\n    }\n\n    var children = tag.children;\n\n    for (var i = 0; i < children.length; i++) if (this.visit(children[i]) !== OPTIMIZABLE.FULL) return OPTIMIZABLE.PARTS;\n\n    if (this.visitAttributes(tag.attrs) !== OPTIMIZABLE.FULL) return OPTIMIZABLE.PARTS;\n    return OPTIMIZABLE.FULL;\n  },\n  visitAttributes: function (attrs) {\n    if (attrs) {\n      var isArray = HTML.isArray(attrs);\n\n      for (var i = 0; i < (isArray ? attrs.length : 1); i++) {\n        var a = isArray ? attrs[i] : attrs;\n        if (typeof a !== 'object' || a instanceof HTMLTools.TemplateTag) return OPTIMIZABLE.PARTS;\n\n        for (var k in a) if (this.visit(a[k]) !== OPTIMIZABLE.FULL) return OPTIMIZABLE.PARTS;\n      }\n    }\n\n    return OPTIMIZABLE.FULL;\n  }\n});\n\nvar getOptimizability = function (content) {\n  return new CanOptimizeVisitor().visit(content);\n};\n\nfunction toRaw(x) {\n  return HTML.Raw(HTML.toHTML(x));\n}\n\nconst TreeTransformer = HTML.TransformingVisitor.extend();\nTreeTransformer.def({\n  visitAttributes: function (attrs\n  /*, ...*/\n  ) {\n    // pass template tags through by default\n    if (attrs instanceof HTMLTools.TemplateTag) return attrs;\n    return HTML.TransformingVisitor.prototype.visitAttributes.apply(this, arguments);\n  }\n}); // Replace parts of the HTMLjs tree that have no template tags (or\n// tricky HTML tags) with HTML.Raw objects containing raw HTML.\n\nvar OptimizingVisitor = TreeTransformer.extend();\nOptimizingVisitor.def({\n  visitNull: toRaw,\n  visitPrimitive: toRaw,\n  visitComment: toRaw,\n  visitCharRef: toRaw,\n  visitArray: function (array) {\n    var optimizability = getOptimizability(array);\n\n    if (optimizability === OPTIMIZABLE.FULL) {\n      return toRaw(array);\n    } else if (optimizability === OPTIMIZABLE.PARTS) {\n      return TreeTransformer.prototype.visitArray.call(this, array);\n    } else {\n      return array;\n    }\n  },\n  visitTag: function (tag) {\n    var optimizability = getOptimizability(tag);\n\n    if (optimizability === OPTIMIZABLE.FULL) {\n      return toRaw(tag);\n    } else if (optimizability === OPTIMIZABLE.PARTS) {\n      return TreeTransformer.prototype.visitTag.call(this, tag);\n    } else {\n      return tag;\n    }\n  },\n  visitChildren: function (children) {\n    // don't optimize the children array into a Raw object!\n    return TreeTransformer.prototype.visitArray.call(this, children);\n  },\n  visitAttributes: function (attrs) {\n    return attrs;\n  }\n}); // Combine consecutive HTML.Raws.  Remove empty ones.\n\nvar RawCompactingVisitor = TreeTransformer.extend();\nRawCompactingVisitor.def({\n  visitArray: function (array) {\n    var result = [];\n\n    for (var i = 0; i < array.length; i++) {\n      var item = array[i];\n\n      if (item instanceof HTML.Raw && (!item.value || result.length && result[result.length - 1] instanceof HTML.Raw)) {\n        // two cases: item is an empty Raw, or previous item is\n        // a Raw as well.  In the latter case, replace the previous\n        // Raw with a longer one that includes the new Raw.\n        if (item.value) {\n          result[result.length - 1] = HTML.Raw(result[result.length - 1].value + item.value);\n        }\n      } else {\n        result.push(this.visit(item));\n      }\n    }\n\n    return result;\n  }\n}); // Replace pointless Raws like `HTMl.Raw('foo')` that contain no special\n// characters with simple strings.\n\nvar RawReplacingVisitor = TreeTransformer.extend();\nRawReplacingVisitor.def({\n  visitRaw: function (raw) {\n    var html = raw.value;\n\n    if (html.indexOf('&') < 0 && html.indexOf('<') < 0) {\n      return html;\n    } else {\n      return raw;\n    }\n  }\n});\n\nfunction optimize(tree) {\n  tree = new OptimizingVisitor().visit(tree);\n  tree = new RawCompactingVisitor().visit(tree);\n  tree = new RawReplacingVisitor().visit(tree);\n  return tree;\n}","map":{"version":3,"sources":["packages/spacebars-compiler/optimizer.js"],"names":["module","export","toRaw","TreeTransformer","optimize","HTMLTools","link","v","HTML","constant","value","OPTIMIZABLE","NONE","PARTS","FULL","CanOptimizeVisitor","Visitor","extend","def","visitNull","visitPrimitive","visitComment","visitCharRef","visitRaw","visitObject","visitFunction","visitArray","x","i","length","visit","visitTag","tag","tagName","isKnownElement","isKnownSVGElement","children","visitAttributes","attrs","isArray","a","TemplateTag","k","getOptimizability","content","Raw","toHTML","TransformingVisitor","prototype","apply","arguments","OptimizingVisitor","array","optimizability","call","visitChildren","RawCompactingVisitor","result","item","push","RawReplacingVisitor","raw","html","indexOf","tree"],"mappings":"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","sourcesContent":["import { HTMLTools } from 'meteor/html-tools';\nimport { HTML } from 'meteor/htmljs';\n\n// Optimize parts of an HTMLjs tree into raw HTML strings when they don't\n// contain template tags.\n\nvar constant = function (value) {\n  return function () { return value; };\n};\n\nvar OPTIMIZABLE = {\n  NONE: 0,\n  PARTS: 1,\n  FULL: 2\n};\n\n// We can only turn content into an HTML string if it contains no template\n// tags and no \"tricky\" HTML tags.  If we can optimize the entire content\n// into a string, we return OPTIMIZABLE.FULL.  If the we are given an\n// unoptimizable node, we return OPTIMIZABLE.NONE.  If we are given a tree\n// that contains an unoptimizable node somewhere, we return OPTIMIZABLE.PARTS.\n//\n// For example, we always create SVG elements programmatically, since SVG\n// doesn't have innerHTML.  If we are given an SVG element, we return NONE.\n// However, if we are given a big tree that contains SVG somewhere, we\n// return PARTS so that the optimizer can descend into the tree and optimize\n// other parts of it.\nvar CanOptimizeVisitor = HTML.Visitor.extend();\nCanOptimizeVisitor.def({\n  visitNull: constant(OPTIMIZABLE.FULL),\n  visitPrimitive: constant(OPTIMIZABLE.FULL),\n  visitComment: constant(OPTIMIZABLE.FULL),\n  visitCharRef: constant(OPTIMIZABLE.FULL),\n  visitRaw: constant(OPTIMIZABLE.FULL),\n  visitObject: constant(OPTIMIZABLE.NONE),\n  visitFunction: constant(OPTIMIZABLE.NONE),\n  visitArray: function (x) {\n    for (var i = 0; i < x.length; i++)\n      if (this.visit(x[i]) !== OPTIMIZABLE.FULL)\n        return OPTIMIZABLE.PARTS;\n    return OPTIMIZABLE.FULL;\n  },\n  visitTag: function (tag) {\n    var tagName = tag.tagName;\n    if (tagName === 'textarea') {\n      // optimizing into a TEXTAREA's RCDATA would require being a little\n      // more clever.\n      return OPTIMIZABLE.NONE;\n    } else if (tagName === 'script') {\n      // script tags don't work when rendered from strings\n      return OPTIMIZABLE.NONE;\n    } else if (! (HTML.isKnownElement(tagName) &&\n                  ! HTML.isKnownSVGElement(tagName))) {\n      // foreign elements like SVG can't be stringified for innerHTML.\n      return OPTIMIZABLE.NONE;\n    } else if (tagName === 'table') {\n      // Avoid ever producing HTML containing `<table><tr>...`, because the\n      // browser will insert a TBODY.  If we just `createElement(\"table\")` and\n      // `createElement(\"tr\")`, on the other hand, no TBODY is necessary\n      // (assuming IE 8+).\n      return OPTIMIZABLE.PARTS;\n    } else if (tagName === 'tr'){\n      return OPTIMIZABLE.PARTS;\n    }\n\n    var children = tag.children;\n    for (var i = 0; i < children.length; i++)\n      if (this.visit(children[i]) !== OPTIMIZABLE.FULL)\n        return OPTIMIZABLE.PARTS;\n\n    if (this.visitAttributes(tag.attrs) !== OPTIMIZABLE.FULL)\n      return OPTIMIZABLE.PARTS;\n\n    return OPTIMIZABLE.FULL;\n  },\n  visitAttributes: function (attrs) {\n    if (attrs) {\n      var isArray = HTML.isArray(attrs);\n      for (var i = 0; i < (isArray ? attrs.length : 1); i++) {\n        var a = (isArray ? attrs[i] : attrs);\n        if ((typeof a !== 'object') || (a instanceof HTMLTools.TemplateTag))\n          return OPTIMIZABLE.PARTS;\n        for (var k in a)\n          if (this.visit(a[k]) !== OPTIMIZABLE.FULL)\n            return OPTIMIZABLE.PARTS;\n      }\n    }\n    return OPTIMIZABLE.FULL;\n  }\n});\n\nvar getOptimizability = function (content) {\n  return (new CanOptimizeVisitor).visit(content);\n};\n\nexport function toRaw(x) {\n  return HTML.Raw(HTML.toHTML(x));\n}\n\nexport const TreeTransformer = HTML.TransformingVisitor.extend();\nTreeTransformer.def({\n  visitAttributes: function (attrs/*, ...*/) {\n    // pass template tags through by default\n    if (attrs instanceof HTMLTools.TemplateTag)\n      return attrs;\n\n    return HTML.TransformingVisitor.prototype.visitAttributes.apply(\n      this, arguments);\n  }\n});\n\n// Replace parts of the HTMLjs tree that have no template tags (or\n// tricky HTML tags) with HTML.Raw objects containing raw HTML.\nvar OptimizingVisitor = TreeTransformer.extend();\nOptimizingVisitor.def({\n  visitNull: toRaw,\n  visitPrimitive: toRaw,\n  visitComment: toRaw,\n  visitCharRef: toRaw,\n  visitArray: function (array) {\n    var optimizability = getOptimizability(array);\n    if (optimizability === OPTIMIZABLE.FULL) {\n      return toRaw(array);\n    } else if (optimizability === OPTIMIZABLE.PARTS) {\n      return TreeTransformer.prototype.visitArray.call(this, array);\n    } else {\n      return array;\n    }\n  },\n  visitTag: function (tag) {\n    var optimizability = getOptimizability(tag);\n    if (optimizability === OPTIMIZABLE.FULL) {\n      return toRaw(tag);\n    } else if (optimizability === OPTIMIZABLE.PARTS) {\n      return TreeTransformer.prototype.visitTag.call(this, tag);\n    } else {\n      return tag;\n    }\n  },\n  visitChildren: function (children) {\n    // don't optimize the children array into a Raw object!\n    return TreeTransformer.prototype.visitArray.call(this, children);\n  },\n  visitAttributes: function (attrs) {\n    return attrs;\n  }\n});\n\n// Combine consecutive HTML.Raws.  Remove empty ones.\nvar RawCompactingVisitor = TreeTransformer.extend();\nRawCompactingVisitor.def({\n  visitArray: function (array) {\n    var result = [];\n    for (var i = 0; i < array.length; i++) {\n      var item = array[i];\n      if ((item instanceof HTML.Raw) &&\n          ((! item.value) ||\n           (result.length &&\n            (result[result.length - 1] instanceof HTML.Raw)))) {\n        // two cases: item is an empty Raw, or previous item is\n        // a Raw as well.  In the latter case, replace the previous\n        // Raw with a longer one that includes the new Raw.\n        if (item.value) {\n          result[result.length - 1] = HTML.Raw(\n            result[result.length - 1].value + item.value);\n        }\n      } else {\n        result.push(this.visit(item));\n      }\n    }\n    return result;\n  }\n});\n\n// Replace pointless Raws like `HTMl.Raw('foo')` that contain no special\n// characters with simple strings.\nvar RawReplacingVisitor = TreeTransformer.extend();\nRawReplacingVisitor.def({\n  visitRaw: function (raw) {\n    var html = raw.value;\n    if (html.indexOf('&') < 0 && html.indexOf('<') < 0) {\n      return html;\n    } else {\n      return raw;\n    }\n  }\n});\n\nexport function optimize (tree) {\n  tree = (new OptimizingVisitor).visit(tree);\n  tree = (new RawCompactingVisitor).visit(tree);\n  tree = (new RawReplacingVisitor).visit(tree);\n  return tree;\n}\n"]},"sourceType":"module","hash":"f382c1dadc12decac80452811688218af3364388"}
