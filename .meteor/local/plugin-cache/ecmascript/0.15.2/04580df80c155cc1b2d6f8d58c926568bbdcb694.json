{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"C:\\Users\\RUBEN\\Desktop\\meteor-vue\\packages\\html-tools\\tokenize.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.windows.x86_64"},"sourceFileName":"packages/html-tools/tokenize.js","filename":"C:\\Users\\RUBEN\\Desktop\\meteor-vue\\packages\\html-tools\\tokenize.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"C:\\Users\\RUBEN\\Desktop\\meteor-vue","root":"C:\\Users\\RUBEN\\Desktop\\meteor-vue","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true}},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.14.0","helpers":true,"useESModules":false,"corejs":false}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":true,"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_verified":true},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}}],"presets":[],"generatorOpts":{"filename":"C:\\Users\\RUBEN\\Desktop\\meteor-vue\\packages\\html-tools\\tokenize.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/html-tools/tokenize.js"}},"code":"module.export({\n  getComment: () => getComment,\n  getDoctype: () => getDoctype,\n  getHTMLToken: () => getHTMLToken,\n  getTagToken: () => getTagToken,\n  TEMPLATE_TAG_POSITION: () => TEMPLATE_TAG_POSITION,\n  isLookingAtEndTag: () => isLookingAtEndTag\n});\nlet asciiLowerCase, properCaseTagName, properCaseAttributeName;\nmodule.link(\"./utils\", {\n  asciiLowerCase(v) {\n    asciiLowerCase = v;\n  },\n\n  properCaseTagName(v) {\n    properCaseTagName = v;\n  },\n\n  properCaseAttributeName(v) {\n    properCaseAttributeName = v;\n  }\n\n}, 0);\nlet TemplateTag;\nmodule.link(\"./templatetag\", {\n  TemplateTag(v) {\n    TemplateTag = v;\n  }\n\n}, 1);\nlet getCharacterReference;\nmodule.link(\"./charref\", {\n  getCharacterReference(v) {\n    getCharacterReference = v;\n  }\n\n}, 2);\nlet makeRegexMatcher;\nmodule.link(\"./scanner\", {\n  makeRegexMatcher(v) {\n    makeRegexMatcher = v;\n  }\n\n}, 3);\n// Token types:\n//\n// { t: 'Doctype',\n//   v: String (entire Doctype declaration from the source),\n//   name: String,\n//   systemId: String (optional),\n//   publicId: String (optional)\n// }\n//\n// { t: 'Comment',\n//   v: String (not including \"<!--\" and \"-->\")\n// }\n//\n// { t: 'Chars',\n//   v: String (pure text like you might pass to document.createTextNode,\n//              no character references)\n// }\n//\n// { t: 'Tag',\n//   isEnd: Boolean (optional),\n//   isSelfClosing: Boolean (optional),\n//   n: String (tag name, in lowercase or camel case),\n//   attrs: dictionary of { String: [tokens] }\n//          OR [{ String: [tokens] }, TemplateTag tokens...]\n//     (only for start tags; required)\n// }\n//\n// { t: 'CharRef',\n//   v: String (entire character reference from the source, e.g. \"&amp;\"),\n//   cp: [Integer] (array of Unicode code point numbers it expands to)\n// }\n//\n// We keep around both the original form of the character reference and its\n// expansion so that subsequent processing steps have the option to\n// re-emit it (if they are generating HTML) or interpret it.  Named and\n// numerical code points may be more than 16 bits, in which case they\n// need to passed through codePointToString to make a JavaScript string.\n// Most named entities and all numeric character references are one codepoint\n// (e.g. \"&amp;\" is [38]), but a few are two codepoints.\n//\n// { t: 'TemplateTag',\n//   v: HTMLTools.TemplateTag\n// }\n// The HTML tokenization spec says to preprocess the input stream to replace\n// CR(LF)? with LF.  However, preprocessing `scanner` would complicate things\n// by making indexes not match the input (e.g. for error messages), so we just\n// keep in mind as we go along that an LF might be represented by CRLF or CR.\n// In most cases, it doesn't actually matter what combination of whitespace\n// characters are present (e.g. inside tags).\nvar HTML_SPACE = /^[\\f\\n\\r\\t ]/;\n\nvar convertCRLF = function (str) {\n  return str.replace(/\\r\\n?/g, '\\n');\n};\n\nfunction getComment(scanner) {\n  if (scanner.rest().slice(0, 4) !== '<!--') return null;\n  scanner.pos += 4; // Valid comments are easy to parse; they end at the first `--`!\n  // Our main job is throwing errors.\n\n  var rest = scanner.rest();\n  if (rest.charAt(0) === '>' || rest.slice(0, 2) === '->') scanner.fatal(\"HTML comment can't start with > or ->\");\n  var closePos = rest.indexOf('-->');\n  if (closePos < 0) scanner.fatal(\"Unclosed HTML comment\");\n  var commentContents = rest.slice(0, closePos);\n  if (commentContents.slice(-1) === '-') scanner.fatal(\"HTML comment must end at first `--`\");\n  if (commentContents.indexOf(\"--\") >= 0) scanner.fatal(\"HTML comment cannot contain `--` anywhere\");\n  if (commentContents.indexOf(\"\\0\") >= 0) scanner.fatal(\"HTML comment cannot contain NULL\");\n  scanner.pos += closePos + 3;\n  return {\n    t: 'Comment',\n    v: convertCRLF(commentContents)\n  };\n}\n\nvar skipSpaces = function (scanner) {\n  while (HTML_SPACE.test(scanner.peek())) scanner.pos++;\n};\n\nvar requireSpaces = function (scanner) {\n  if (!HTML_SPACE.test(scanner.peek())) scanner.fatal(\"Expected space\");\n  skipSpaces(scanner);\n};\n\nvar getDoctypeQuotedString = function (scanner) {\n  var quote = scanner.peek();\n  if (!(quote === '\"' || quote === \"'\")) scanner.fatal(\"Expected single or double quote in DOCTYPE\");\n  scanner.pos++;\n  if (scanner.peek() === quote) // prevent a falsy return value (empty string)\n    scanner.fatal(\"Malformed DOCTYPE\");\n  var str = '';\n  var ch;\n\n  while (ch = scanner.peek(), ch !== quote) {\n    if (!ch || ch === \"\\0\" || ch === '>') scanner.fatal(\"Malformed DOCTYPE\");\n    str += ch;\n    scanner.pos++;\n  }\n\n  scanner.pos++;\n  return str;\n}; // See http://www.whatwg.org/specs/web-apps/current-work/multipage/syntax.html#the-doctype.\n//\n// If `getDocType` sees \"<!DOCTYPE\" (case-insensitive), it will match or fail fatally.\n\n\nfunction getDoctype(scanner) {\n  if (asciiLowerCase(scanner.rest().slice(0, 9)) !== '<!doctype') return null;\n  var start = scanner.pos;\n  scanner.pos += 9;\n  requireSpaces(scanner);\n  var ch = scanner.peek();\n  if (!ch || ch === '>' || ch === \"\\0\") scanner.fatal('Malformed DOCTYPE');\n  var name = ch;\n  scanner.pos++;\n\n  while (ch = scanner.peek(), !(HTML_SPACE.test(ch) || ch === '>')) {\n    if (!ch || ch === \"\\0\") scanner.fatal('Malformed DOCTYPE');\n    name += ch;\n    scanner.pos++;\n  }\n\n  name = asciiLowerCase(name); // Now we're looking at a space or a `>`.\n\n  skipSpaces(scanner);\n  var systemId = null;\n  var publicId = null;\n\n  if (scanner.peek() !== '>') {\n    // Now we're essentially in the \"After DOCTYPE name state\" of the tokenizer,\n    // but we're not looking at space or `>`.\n    // this should be \"public\" or \"system\".\n    var publicOrSystem = asciiLowerCase(scanner.rest().slice(0, 6));\n\n    if (publicOrSystem === 'system') {\n      scanner.pos += 6;\n      requireSpaces(scanner);\n      systemId = getDoctypeQuotedString(scanner);\n      skipSpaces(scanner);\n      if (scanner.peek() !== '>') scanner.fatal(\"Malformed DOCTYPE\");\n    } else if (publicOrSystem === 'public') {\n      scanner.pos += 6;\n      requireSpaces(scanner);\n      publicId = getDoctypeQuotedString(scanner);\n\n      if (scanner.peek() !== '>') {\n        requireSpaces(scanner);\n\n        if (scanner.peek() !== '>') {\n          systemId = getDoctypeQuotedString(scanner);\n          skipSpaces(scanner);\n          if (scanner.peek() !== '>') scanner.fatal(\"Malformed DOCTYPE\");\n        }\n      }\n    } else {\n      scanner.fatal(\"Expected PUBLIC or SYSTEM in DOCTYPE\");\n    }\n  } // looking at `>`\n\n\n  scanner.pos++;\n  var result = {\n    t: 'Doctype',\n    v: scanner.input.slice(start, scanner.pos),\n    name: name\n  };\n  if (systemId) result.systemId = systemId;\n  if (publicId) result.publicId = publicId;\n  return result;\n}\n\n// The special character `{` is only allowed as the first character\n// of a Chars, so that we have a chance to detect template tags.\nvar getChars = makeRegexMatcher(/^[^&<\\u0000][^&<\\u0000{]*/);\n\nvar assertIsTemplateTag = function (x) {\n  if (!(x instanceof TemplateTag)) throw new Error(\"Expected an instance of HTMLTools.TemplateTag\");\n  return x;\n}; // Returns the next HTML token, or `null` if we reach EOF.\n//\n// Note that if we have a `getTemplateTag` function that sometimes\n// consumes characters and emits nothing (e.g. in the case of template\n// comments), we may go from not-at-EOF to at-EOF and return `null`,\n// while otherwise we always find some token to return.\n\n\nfunction getHTMLToken(scanner, dataMode) {\n  var result = null;\n\n  if (scanner.getTemplateTag) {\n    // Try to parse a template tag by calling out to the provided\n    // `getTemplateTag` function.  If the function returns `null` but\n    // consumes characters, it must have parsed a comment or something,\n    // so we loop and try it again.  If it ever returns `null` without\n    // consuming anything, that means it didn't see anything interesting\n    // so we look for a normal token.  If it returns a truthy value,\n    // the value must be instanceof HTMLTools.TemplateTag.  We wrap it\n    // in a Special token.\n    var lastPos = scanner.pos;\n    result = scanner.getTemplateTag(scanner, dataMode === 'rcdata' ? TEMPLATE_TAG_POSITION.IN_RCDATA : dataMode === 'rawtext' ? TEMPLATE_TAG_POSITION.IN_RAWTEXT : TEMPLATE_TAG_POSITION.ELEMENT);\n    if (result) return {\n      t: 'TemplateTag',\n      v: assertIsTemplateTag(result)\n    };else if (scanner.pos > lastPos) return null;\n  }\n\n  var chars = getChars(scanner);\n  if (chars) return {\n    t: 'Chars',\n    v: convertCRLF(chars)\n  };\n  var ch = scanner.peek();\n  if (!ch) return null; // EOF\n\n  if (ch === \"\\0\") scanner.fatal(\"Illegal NULL character\");\n\n  if (ch === '&') {\n    if (dataMode !== 'rawtext') {\n      var charRef = getCharacterReference(scanner);\n      if (charRef) return charRef;\n    }\n\n    scanner.pos++;\n    return {\n      t: 'Chars',\n      v: '&'\n    };\n  } // If we're here, we're looking at `<`.\n\n\n  if (scanner.peek() === '<' && dataMode) {\n    // don't interpret tags\n    scanner.pos++;\n    return {\n      t: 'Chars',\n      v: '<'\n    };\n  } // `getTag` will claim anything starting with `<` not followed by `!`.\n  // `getComment` takes `<!--` and getDoctype takes `<!doctype`.\n\n\n  result = getTagToken(scanner) || getComment(scanner) || getDoctype(scanner);\n  if (result) return result;\n  scanner.fatal(\"Unexpected `<!` directive.\");\n}\n\nvar getTagName = makeRegexMatcher(/^[a-zA-Z][^\\f\\n\\r\\t />{]*/);\nvar getClangle = makeRegexMatcher(/^>/);\nvar getSlash = makeRegexMatcher(/^\\//);\nvar getAttributeName = makeRegexMatcher(/^[^>/\\u0000\"'<=\\f\\n\\r\\t ][^\\f\\n\\r\\t /=>\"'<\\u0000]*/); // Try to parse `>` or `/>`, mutating `tag` to be self-closing in the latter\n// case (and failing fatally if `/` isn't followed by `>`).\n// Return tag if successful.\n\nvar handleEndOfTag = function (scanner, tag) {\n  if (getClangle(scanner)) return tag;\n\n  if (getSlash(scanner)) {\n    if (!getClangle(scanner)) scanner.fatal(\"Expected `>` after `/`\");\n    tag.isSelfClosing = true;\n    return tag;\n  }\n\n  return null;\n}; // Scan a quoted or unquoted attribute value (omit `quote` for unquoted).\n\n\nvar getAttributeValue = function (scanner, quote) {\n  if (quote) {\n    if (scanner.peek() !== quote) return null;\n    scanner.pos++;\n  }\n\n  var tokens = [];\n  var charsTokenToExtend = null;\n  var charRef;\n\n  while (true) {\n    var ch = scanner.peek();\n    var templateTag;\n    var curPos = scanner.pos;\n\n    if (quote && ch === quote) {\n      scanner.pos++;\n      return tokens;\n    } else if (!quote && (HTML_SPACE.test(ch) || ch === '>')) {\n      return tokens;\n    } else if (!ch) {\n      scanner.fatal(\"Unclosed attribute in tag\");\n    } else if (quote ? ch === \"\\0\" : \"\\0\\\"'<=`\".indexOf(ch) >= 0) {\n      scanner.fatal(\"Unexpected character in attribute value\");\n    } else if (ch === '&' && (charRef = getCharacterReference(scanner, true, quote || '>'))) {\n      tokens.push(charRef);\n      charsTokenToExtend = null;\n    } else if (scanner.getTemplateTag && ((templateTag = scanner.getTemplateTag(scanner, TEMPLATE_TAG_POSITION.IN_ATTRIBUTE)) || scanner.pos > curPos\n    /* `{{! comment}}` */\n    )) {\n      if (templateTag) {\n        tokens.push({\n          t: 'TemplateTag',\n          v: assertIsTemplateTag(templateTag)\n        });\n        charsTokenToExtend = null;\n      }\n    } else {\n      if (!charsTokenToExtend) {\n        charsTokenToExtend = {\n          t: 'Chars',\n          v: ''\n        };\n        tokens.push(charsTokenToExtend);\n      }\n\n      charsTokenToExtend.v += ch === '\\r' ? '\\n' : ch;\n      scanner.pos++;\n      if (quote && ch === '\\r' && scanner.peek() === '\\n') scanner.pos++;\n    }\n  }\n};\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction getTagToken(scanner) {\n  if (!(scanner.peek() === '<' && scanner.rest().charAt(1) !== '!')) return null;\n  scanner.pos++;\n  var tag = {\n    t: 'Tag'\n  }; // now looking at the character after `<`, which is not a `!`\n\n  if (scanner.peek() === '/') {\n    tag.isEnd = true;\n    scanner.pos++;\n  }\n\n  var tagName = getTagName(scanner);\n  if (!tagName) scanner.fatal(\"Expected tag name after `<`\");\n  tag.n = properCaseTagName(tagName);\n  if (scanner.peek() === '/' && tag.isEnd) scanner.fatal(\"End tag can't have trailing slash\");\n  if (handleEndOfTag(scanner, tag)) return tag;\n  if (scanner.isEOF()) scanner.fatal(\"Unclosed `<`\");\n  if (!HTML_SPACE.test(scanner.peek())) // e.g. `<a{{b}}>`\n    scanner.fatal(\"Expected space after tag name\"); // we're now in \"Before attribute name state\" of the tokenizer\n\n  skipSpaces(scanner);\n  if (scanner.peek() === '/' && tag.isEnd) scanner.fatal(\"End tag can't have trailing slash\");\n  if (handleEndOfTag(scanner, tag)) return tag;\n  if (tag.isEnd) scanner.fatal(\"End tag can't have attributes\");\n  tag.attrs = {};\n  var nondynamicAttrs = tag.attrs;\n\n  while (true) {\n    // Note: at the top of this loop, we've already skipped any spaces.\n    // This will be set to true if after parsing the attribute, we should\n    // require spaces (or else an end of tag, i.e. `>` or `/>`).\n    var spacesRequiredAfter = false; // first, try for a template tag.\n\n    var curPos = scanner.pos;\n    var templateTag = scanner.getTemplateTag && scanner.getTemplateTag(scanner, TEMPLATE_TAG_POSITION.IN_START_TAG);\n\n    if (templateTag || scanner.pos > curPos) {\n      if (templateTag) {\n        if (tag.attrs === nondynamicAttrs) tag.attrs = [nondynamicAttrs];\n        tag.attrs.push({\n          t: 'TemplateTag',\n          v: assertIsTemplateTag(templateTag)\n        });\n      } // else, must have scanned a `{{! comment}}`\n\n\n      spacesRequiredAfter = true;\n    } else {\n      var attributeName = getAttributeName(scanner);\n      if (!attributeName) scanner.fatal(\"Expected attribute name in tag\"); // Throw error on `{` in attribute name.  This provides *some* error message\n      // if someone writes `<a x{{y}}>` or `<a x{{y}}=z>`.  The HTML tokenization\n      // spec doesn't say that `{` is invalid, but the DOM API (setAttribute) won't\n      // allow it, so who cares.\n\n      if (attributeName.indexOf('{') >= 0) scanner.fatal(\"Unexpected `{` in attribute name.\");\n      attributeName = properCaseAttributeName(attributeName);\n      if (hasOwnProperty.call(nondynamicAttrs, attributeName)) scanner.fatal(\"Duplicate attribute in tag: \" + attributeName);\n      nondynamicAttrs[attributeName] = [];\n      skipSpaces(scanner);\n      if (handleEndOfTag(scanner, tag)) return tag;\n      var ch = scanner.peek();\n      if (!ch) scanner.fatal(\"Unclosed <\");\n      if (\"\\0\\\"'<\".indexOf(ch) >= 0) scanner.fatal(\"Unexpected character after attribute name in tag\");\n\n      if (ch === '=') {\n        scanner.pos++;\n        skipSpaces(scanner);\n        ch = scanner.peek();\n        if (!ch) scanner.fatal(\"Unclosed <\");\n        if (\"\\0><=`\".indexOf(ch) >= 0) scanner.fatal(\"Unexpected character after = in tag\");\n        if (ch === '\"' || ch === \"'\") nondynamicAttrs[attributeName] = getAttributeValue(scanner, ch);else nondynamicAttrs[attributeName] = getAttributeValue(scanner);\n        spacesRequiredAfter = true;\n      }\n    } // now we are in the \"post-attribute\" position, whether it was a template tag\n    // attribute (like `{{x}}`) or a normal one (like `x` or `x=y`).\n\n\n    if (handleEndOfTag(scanner, tag)) return tag;\n    if (scanner.isEOF()) scanner.fatal(\"Unclosed `<`\");\n    if (spacesRequiredAfter) requireSpaces(scanner);else skipSpaces(scanner);\n    if (handleEndOfTag(scanner, tag)) return tag;\n  }\n}\n\nconst TEMPLATE_TAG_POSITION = {\n  ELEMENT: 1,\n  IN_START_TAG: 2,\n  IN_ATTRIBUTE: 3,\n  IN_RCDATA: 4,\n  IN_RAWTEXT: 5\n};\n\nfunction isLookingAtEndTag(scanner, tagName) {\n  var rest = scanner.rest();\n  var pos = 0; // into rest\n\n  var firstPart = /^<\\/([a-zA-Z]+)/.exec(rest);\n\n  if (firstPart && properCaseTagName(firstPart[1]) === tagName) {\n    // we've seen `</foo`, now see if the end tag continues\n    pos += firstPart[0].length;\n\n    while (pos < rest.length && HTML_SPACE.test(rest.charAt(pos))) pos++;\n\n    if (pos < rest.length && rest.charAt(pos) === '>') return true;\n  }\n\n  return false;\n}","map":{"version":3,"sources":["packages/html-tools/tokenize.js"],"names":["module","export","getComment","getDoctype","getHTMLToken","getTagToken","TEMPLATE_TAG_POSITION","isLookingAtEndTag","asciiLowerCase","properCaseTagName","properCaseAttributeName","link","v","TemplateTag","getCharacterReference","makeRegexMatcher","HTML_SPACE","convertCRLF","str","replace","scanner","rest","slice","pos","charAt","fatal","closePos","indexOf","commentContents","t","skipSpaces","test","peek","requireSpaces","getDoctypeQuotedString","quote","ch","start","name","systemId","publicId","publicOrSystem","result","input","getChars","assertIsTemplateTag","x","Error","dataMode","getTemplateTag","lastPos","IN_RCDATA","IN_RAWTEXT","ELEMENT","chars","charRef","getTagName","getClangle","getSlash","getAttributeName","handleEndOfTag","tag","isSelfClosing","getAttributeValue","tokens","charsTokenToExtend","templateTag","curPos","push","IN_ATTRIBUTE","hasOwnProperty","Object","prototype","isEnd","tagName","n","isEOF","attrs","nondynamicAttrs","spacesRequiredAfter","IN_START_TAG","attributeName","call","firstPart","exec","length"],"mappings":"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","sourcesContent":["import { asciiLowerCase, properCaseTagName, properCaseAttributeName } from './utils';\nimport { TemplateTag } from './templatetag';\nimport { getCharacterReference } from './charref';\nimport { makeRegexMatcher } from './scanner';\n\n// Token types:\n//\n// { t: 'Doctype',\n//   v: String (entire Doctype declaration from the source),\n//   name: String,\n//   systemId: String (optional),\n//   publicId: String (optional)\n// }\n//\n// { t: 'Comment',\n//   v: String (not including \"<!--\" and \"-->\")\n// }\n//\n// { t: 'Chars',\n//   v: String (pure text like you might pass to document.createTextNode,\n//              no character references)\n// }\n//\n// { t: 'Tag',\n//   isEnd: Boolean (optional),\n//   isSelfClosing: Boolean (optional),\n//   n: String (tag name, in lowercase or camel case),\n//   attrs: dictionary of { String: [tokens] }\n//          OR [{ String: [tokens] }, TemplateTag tokens...]\n//     (only for start tags; required)\n// }\n//\n// { t: 'CharRef',\n//   v: String (entire character reference from the source, e.g. \"&amp;\"),\n//   cp: [Integer] (array of Unicode code point numbers it expands to)\n// }\n//\n// We keep around both the original form of the character reference and its\n// expansion so that subsequent processing steps have the option to\n// re-emit it (if they are generating HTML) or interpret it.  Named and\n// numerical code points may be more than 16 bits, in which case they\n// need to passed through codePointToString to make a JavaScript string.\n// Most named entities and all numeric character references are one codepoint\n// (e.g. \"&amp;\" is [38]), but a few are two codepoints.\n//\n// { t: 'TemplateTag',\n//   v: HTMLTools.TemplateTag\n// }\n\n// The HTML tokenization spec says to preprocess the input stream to replace\n// CR(LF)? with LF.  However, preprocessing `scanner` would complicate things\n// by making indexes not match the input (e.g. for error messages), so we just\n// keep in mind as we go along that an LF might be represented by CRLF or CR.\n// In most cases, it doesn't actually matter what combination of whitespace\n// characters are present (e.g. inside tags).\nvar HTML_SPACE = /^[\\f\\n\\r\\t ]/;\n\nvar convertCRLF = function (str) {\n  return str.replace(/\\r\\n?/g, '\\n');\n};\n\nexport function getComment (scanner) {\n  if (scanner.rest().slice(0, 4) !== '<!--')\n    return null;\n  scanner.pos += 4;\n\n  // Valid comments are easy to parse; they end at the first `--`!\n  // Our main job is throwing errors.\n\n  var rest = scanner.rest();\n  if (rest.charAt(0) === '>' || rest.slice(0, 2) === '->')\n    scanner.fatal(\"HTML comment can't start with > or ->\");\n\n  var closePos = rest.indexOf('-->');\n  if (closePos < 0)\n    scanner.fatal(\"Unclosed HTML comment\");\n\n  var commentContents = rest.slice(0, closePos);\n  if (commentContents.slice(-1) === '-')\n    scanner.fatal(\"HTML comment must end at first `--`\");\n  if (commentContents.indexOf(\"--\") >= 0)\n    scanner.fatal(\"HTML comment cannot contain `--` anywhere\");\n  if (commentContents.indexOf('\\u0000') >= 0)\n    scanner.fatal(\"HTML comment cannot contain NULL\");\n\n  scanner.pos += closePos + 3;\n\n  return { t: 'Comment',\n           v: convertCRLF(commentContents) };\n}\n\nvar skipSpaces = function (scanner) {\n  while (HTML_SPACE.test(scanner.peek()))\n    scanner.pos++;\n};\n\nvar requireSpaces = function (scanner) {\n  if (! HTML_SPACE.test(scanner.peek()))\n    scanner.fatal(\"Expected space\");\n  skipSpaces(scanner);\n};\n\nvar getDoctypeQuotedString = function (scanner) {\n  var quote = scanner.peek();\n  if (! (quote === '\"' || quote === \"'\"))\n    scanner.fatal(\"Expected single or double quote in DOCTYPE\");\n  scanner.pos++;\n\n  if (scanner.peek() === quote)\n    // prevent a falsy return value (empty string)\n    scanner.fatal(\"Malformed DOCTYPE\");\n\n  var str = '';\n  var ch;\n  while ((ch = scanner.peek()), ch !== quote) {\n    if ((! ch) || (ch === '\\u0000') || (ch === '>'))\n      scanner.fatal(\"Malformed DOCTYPE\");\n    str += ch;\n    scanner.pos++;\n  }\n\n  scanner.pos++;\n\n  return str;\n};\n\n// See http://www.whatwg.org/specs/web-apps/current-work/multipage/syntax.html#the-doctype.\n//\n// If `getDocType` sees \"<!DOCTYPE\" (case-insensitive), it will match or fail fatally.\nexport function getDoctype (scanner) {\n  if (asciiLowerCase(scanner.rest().slice(0, 9)) !== '<!doctype')\n    return null;\n  var start = scanner.pos;\n  scanner.pos += 9;\n\n  requireSpaces(scanner);\n\n  var ch = scanner.peek();\n  if ((! ch) || (ch === '>') || (ch === '\\u0000'))\n    scanner.fatal('Malformed DOCTYPE');\n  var name = ch;\n  scanner.pos++;\n\n  while ((ch = scanner.peek()), ! (HTML_SPACE.test(ch) || ch === '>')) {\n    if ((! ch) || (ch === '\\u0000'))\n      scanner.fatal('Malformed DOCTYPE');\n    name += ch;\n    scanner.pos++;\n  }\n  name = asciiLowerCase(name);\n\n  // Now we're looking at a space or a `>`.\n  skipSpaces(scanner);\n\n  var systemId = null;\n  var publicId = null;\n\n  if (scanner.peek() !== '>') {\n    // Now we're essentially in the \"After DOCTYPE name state\" of the tokenizer,\n    // but we're not looking at space or `>`.\n\n    // this should be \"public\" or \"system\".\n    var publicOrSystem = asciiLowerCase(scanner.rest().slice(0, 6));\n\n    if (publicOrSystem === 'system') {\n      scanner.pos += 6;\n      requireSpaces(scanner);\n      systemId = getDoctypeQuotedString(scanner);\n      skipSpaces(scanner);\n      if (scanner.peek() !== '>')\n        scanner.fatal(\"Malformed DOCTYPE\");\n    } else if (publicOrSystem === 'public') {\n      scanner.pos += 6;\n      requireSpaces(scanner);\n      publicId = getDoctypeQuotedString(scanner);\n      if (scanner.peek() !== '>') {\n        requireSpaces(scanner);\n        if (scanner.peek() !== '>') {\n          systemId = getDoctypeQuotedString(scanner);\n          skipSpaces(scanner);\n          if (scanner.peek() !== '>')\n            scanner.fatal(\"Malformed DOCTYPE\");\n        }\n      }\n    } else {\n      scanner.fatal(\"Expected PUBLIC or SYSTEM in DOCTYPE\");\n    }\n  }\n\n  // looking at `>`\n  scanner.pos++;\n  var result = { t: 'Doctype',\n                 v: scanner.input.slice(start, scanner.pos),\n                 name: name };\n\n  if (systemId)\n    result.systemId = systemId;\n  if (publicId)\n    result.publicId = publicId;\n\n  return result;\n}\n\n// The special character `{` is only allowed as the first character\n// of a Chars, so that we have a chance to detect template tags.\nvar getChars = makeRegexMatcher(/^[^&<\\u0000][^&<\\u0000{]*/);\n\nvar assertIsTemplateTag = function (x) {\n  if (! (x instanceof TemplateTag))\n    throw new Error(\"Expected an instance of HTMLTools.TemplateTag\");\n  return x;\n};\n\n// Returns the next HTML token, or `null` if we reach EOF.\n//\n// Note that if we have a `getTemplateTag` function that sometimes\n// consumes characters and emits nothing (e.g. in the case of template\n// comments), we may go from not-at-EOF to at-EOF and return `null`,\n// while otherwise we always find some token to return.\nexport function getHTMLToken (scanner, dataMode) {\n  var result = null;\n  if (scanner.getTemplateTag) {\n    // Try to parse a template tag by calling out to the provided\n    // `getTemplateTag` function.  If the function returns `null` but\n    // consumes characters, it must have parsed a comment or something,\n    // so we loop and try it again.  If it ever returns `null` without\n    // consuming anything, that means it didn't see anything interesting\n    // so we look for a normal token.  If it returns a truthy value,\n    // the value must be instanceof HTMLTools.TemplateTag.  We wrap it\n    // in a Special token.\n    var lastPos = scanner.pos;\n    result = scanner.getTemplateTag(\n      scanner,\n      (dataMode === 'rcdata' ? TEMPLATE_TAG_POSITION.IN_RCDATA :\n       (dataMode === 'rawtext' ? TEMPLATE_TAG_POSITION.IN_RAWTEXT :\n        TEMPLATE_TAG_POSITION.ELEMENT)));\n\n    if (result)\n      return { t: 'TemplateTag', v: assertIsTemplateTag(result) };\n    else if (scanner.pos > lastPos)\n      return null;\n  }\n\n  var chars = getChars(scanner);\n  if (chars)\n    return { t: 'Chars',\n             v: convertCRLF(chars) };\n\n  var ch = scanner.peek();\n  if (! ch)\n    return null; // EOF\n\n  if (ch === '\\u0000')\n    scanner.fatal(\"Illegal NULL character\");\n\n  if (ch === '&') {\n    if (dataMode !== 'rawtext') {\n      var charRef = getCharacterReference(scanner);\n      if (charRef)\n        return charRef;\n    }\n\n    scanner.pos++;\n    return { t: 'Chars',\n             v: '&' };\n  }\n\n  // If we're here, we're looking at `<`.\n\n  if (scanner.peek() === '<' && dataMode) {\n    // don't interpret tags\n    scanner.pos++;\n    return { t: 'Chars',\n             v: '<' };\n  }\n\n  // `getTag` will claim anything starting with `<` not followed by `!`.\n  // `getComment` takes `<!--` and getDoctype takes `<!doctype`.\n  result = (getTagToken(scanner) || getComment(scanner) || getDoctype(scanner));\n\n  if (result)\n    return result;\n\n  scanner.fatal(\"Unexpected `<!` directive.\");\n}\n\nvar getTagName = makeRegexMatcher(/^[a-zA-Z][^\\f\\n\\r\\t />{]*/);\nvar getClangle = makeRegexMatcher(/^>/);\nvar getSlash = makeRegexMatcher(/^\\//);\nvar getAttributeName = makeRegexMatcher(/^[^>/\\u0000\"'<=\\f\\n\\r\\t ][^\\f\\n\\r\\t /=>\"'<\\u0000]*/);\n\n// Try to parse `>` or `/>`, mutating `tag` to be self-closing in the latter\n// case (and failing fatally if `/` isn't followed by `>`).\n// Return tag if successful.\nvar handleEndOfTag = function (scanner, tag) {\n  if (getClangle(scanner))\n    return tag;\n\n  if (getSlash(scanner)) {\n    if (! getClangle(scanner))\n      scanner.fatal(\"Expected `>` after `/`\");\n    tag.isSelfClosing = true;\n    return tag;\n  }\n\n  return null;\n};\n\n// Scan a quoted or unquoted attribute value (omit `quote` for unquoted).\nvar getAttributeValue = function (scanner, quote) {\n  if (quote) {\n    if (scanner.peek() !== quote)\n      return null;\n    scanner.pos++;\n  }\n\n  var tokens = [];\n  var charsTokenToExtend = null;\n\n  var charRef;\n  while (true) {\n    var ch = scanner.peek();\n    var templateTag;\n    var curPos = scanner.pos;\n    if (quote && ch === quote) {\n      scanner.pos++;\n      return tokens;\n    } else if ((! quote) && (HTML_SPACE.test(ch) || ch === '>')) {\n      return tokens;\n    } else if (! ch) {\n      scanner.fatal(\"Unclosed attribute in tag\");\n    } else if (quote ? ch === '\\u0000' : ('\\u0000\"\\'<=`'.indexOf(ch) >= 0)) {\n      scanner.fatal(\"Unexpected character in attribute value\");\n    } else if (ch === '&' &&\n               (charRef = getCharacterReference(scanner, true,\n                                                quote || '>'))) {\n      tokens.push(charRef);\n      charsTokenToExtend = null;\n    } else if (scanner.getTemplateTag &&\n               ((templateTag = scanner.getTemplateTag(\n                 scanner, TEMPLATE_TAG_POSITION.IN_ATTRIBUTE)) ||\n                scanner.pos > curPos /* `{{! comment}}` */)) {\n      if (templateTag) {\n        tokens.push({t: 'TemplateTag',\n                     v: assertIsTemplateTag(templateTag)});\n        charsTokenToExtend = null;\n      }\n    } else {\n      if (! charsTokenToExtend) {\n        charsTokenToExtend = { t: 'Chars', v: '' };\n        tokens.push(charsTokenToExtend);\n      }\n      charsTokenToExtend.v += (ch === '\\r' ? '\\n' : ch);\n      scanner.pos++;\n      if (quote && ch === '\\r' && scanner.peek() === '\\n')\n        scanner.pos++;\n    }\n  }\n};\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nexport function getTagToken(scanner) {\n  if (! (scanner.peek() === '<' && scanner.rest().charAt(1) !== '!'))\n    return null;\n  scanner.pos++;\n\n  var tag = { t: 'Tag' };\n\n  // now looking at the character after `<`, which is not a `!`\n  if (scanner.peek() === '/') {\n    tag.isEnd = true;\n    scanner.pos++;\n  }\n\n  var tagName = getTagName(scanner);\n  if (! tagName)\n    scanner.fatal(\"Expected tag name after `<`\");\n  tag.n = properCaseTagName(tagName);\n\n  if (scanner.peek() === '/' && tag.isEnd)\n    scanner.fatal(\"End tag can't have trailing slash\");\n  if (handleEndOfTag(scanner, tag))\n    return tag;\n\n  if (scanner.isEOF())\n    scanner.fatal(\"Unclosed `<`\");\n\n  if (! HTML_SPACE.test(scanner.peek()))\n    // e.g. `<a{{b}}>`\n    scanner.fatal(\"Expected space after tag name\");\n\n  // we're now in \"Before attribute name state\" of the tokenizer\n  skipSpaces(scanner);\n\n  if (scanner.peek() === '/' && tag.isEnd)\n    scanner.fatal(\"End tag can't have trailing slash\");\n  if (handleEndOfTag(scanner, tag))\n    return tag;\n\n  if (tag.isEnd)\n    scanner.fatal(\"End tag can't have attributes\");\n\n  tag.attrs = {};\n  var nondynamicAttrs = tag.attrs;\n\n  while (true) {\n    // Note: at the top of this loop, we've already skipped any spaces.\n\n    // This will be set to true if after parsing the attribute, we should\n    // require spaces (or else an end of tag, i.e. `>` or `/>`).\n    var spacesRequiredAfter = false;\n\n    // first, try for a template tag.\n    var curPos = scanner.pos;\n    var templateTag = (scanner.getTemplateTag &&\n                       scanner.getTemplateTag(\n                         scanner, TEMPLATE_TAG_POSITION.IN_START_TAG));\n    if (templateTag || (scanner.pos > curPos)) {\n      if (templateTag) {\n        if (tag.attrs === nondynamicAttrs)\n          tag.attrs = [nondynamicAttrs];\n        tag.attrs.push({ t: 'TemplateTag',\n                         v: assertIsTemplateTag(templateTag) });\n      } // else, must have scanned a `{{! comment}}`\n\n      spacesRequiredAfter = true;\n    } else {\n\n      var attributeName = getAttributeName(scanner);\n      if (! attributeName)\n        scanner.fatal(\"Expected attribute name in tag\");\n      // Throw error on `{` in attribute name.  This provides *some* error message\n      // if someone writes `<a x{{y}}>` or `<a x{{y}}=z>`.  The HTML tokenization\n      // spec doesn't say that `{` is invalid, but the DOM API (setAttribute) won't\n      // allow it, so who cares.\n      if (attributeName.indexOf('{') >= 0)\n        scanner.fatal(\"Unexpected `{` in attribute name.\");\n      attributeName = properCaseAttributeName(attributeName);\n\n      if (hasOwnProperty.call(nondynamicAttrs, attributeName))\n        scanner.fatal(\"Duplicate attribute in tag: \" + attributeName);\n\n      nondynamicAttrs[attributeName] = [];\n\n      skipSpaces(scanner);\n\n      if (handleEndOfTag(scanner, tag))\n        return tag;\n\n      var ch = scanner.peek();\n      if (! ch)\n        scanner.fatal(\"Unclosed <\");\n      if ('\\u0000\"\\'<'.indexOf(ch) >= 0)\n        scanner.fatal(\"Unexpected character after attribute name in tag\");\n\n      if (ch === '=') {\n        scanner.pos++;\n\n        skipSpaces(scanner);\n\n        ch = scanner.peek();\n        if (! ch)\n          scanner.fatal(\"Unclosed <\");\n        if ('\\u0000><=`'.indexOf(ch) >= 0)\n          scanner.fatal(\"Unexpected character after = in tag\");\n\n        if ((ch === '\"') || (ch === \"'\"))\n          nondynamicAttrs[attributeName] = getAttributeValue(scanner, ch);\n        else\n          nondynamicAttrs[attributeName] = getAttributeValue(scanner);\n\n        spacesRequiredAfter = true;\n      }\n    }\n    // now we are in the \"post-attribute\" position, whether it was a template tag\n    // attribute (like `{{x}}`) or a normal one (like `x` or `x=y`).\n\n    if (handleEndOfTag(scanner, tag))\n      return tag;\n\n    if (scanner.isEOF())\n      scanner.fatal(\"Unclosed `<`\");\n\n    if (spacesRequiredAfter)\n      requireSpaces(scanner);\n    else\n      skipSpaces(scanner);\n\n    if (handleEndOfTag(scanner, tag))\n      return tag;\n  }\n}\n\nexport const TEMPLATE_TAG_POSITION = {\n  ELEMENT: 1,\n  IN_START_TAG: 2,\n  IN_ATTRIBUTE: 3,\n  IN_RCDATA: 4,\n  IN_RAWTEXT: 5\n};\n\n// tagName must be proper case\nexport function isLookingAtEndTag (scanner, tagName) {\n  var rest = scanner.rest();\n  var pos = 0; // into rest\n  var firstPart = /^<\\/([a-zA-Z]+)/.exec(rest);\n  if (firstPart &&\n      properCaseTagName(firstPart[1]) === tagName) {\n    // we've seen `</foo`, now see if the end tag continues\n    pos += firstPart[0].length;\n    while (pos < rest.length && HTML_SPACE.test(rest.charAt(pos)))\n      pos++;\n    if (pos < rest.length && rest.charAt(pos) === '>')\n      return true;\n  }\n  return false;\n}\n"]},"sourceType":"module","hash":"04580df80c155cc1b2d6f8d58c926568bbdcb694"}
