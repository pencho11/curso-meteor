{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"C:\\Users\\RUBEN\\Desktop\\meteor-vue\\packages\\spacebars-compiler\\templatetag.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.windows.x86_64"},"sourceFileName":"packages/spacebars-compiler/templatetag.js","filename":"C:\\Users\\RUBEN\\Desktop\\meteor-vue\\packages\\spacebars-compiler\\templatetag.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"C:\\Users\\RUBEN\\Desktop\\meteor-vue","root":"C:\\Users\\RUBEN\\Desktop\\meteor-vue","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true}},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.14.0","helpers":true,"useESModules":false,"corejs":false}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":true,"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_verified":true},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}}],"presets":[],"generatorOpts":{"filename":"C:\\Users\\RUBEN\\Desktop\\meteor-vue\\packages\\spacebars-compiler\\templatetag.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/spacebars-compiler/templatetag.js"}},"code":"module.export({\n  TemplateTag: () => TemplateTag\n});\nlet HTMLTools;\nmodule.link(\"meteor/html-tools\", {\n  HTMLTools(v) {\n    HTMLTools = v;\n  }\n\n}, 0);\nlet HTML;\nmodule.link(\"meteor/htmljs\", {\n  HTML(v) {\n    HTML = v;\n  }\n\n}, 1);\nlet BlazeTools;\nmodule.link(\"meteor/blaze-tools\", {\n  BlazeTools(v) {\n    BlazeTools = v;\n  }\n\n}, 2);\n// A TemplateTag is the result of parsing a single `{{...}}` tag.\n//\n// The `.type` of a TemplateTag is one of:\n//\n// - `\"DOUBLE\"` - `{{foo}}`\n// - `\"TRIPLE\"` - `{{{foo}}}`\n// - `\"EXPR\"` - `(foo)`\n// - `\"COMMENT\"` - `{{! foo}}`\n// - `\"BLOCKCOMMENT\" - `{{!-- foo--}}`\n// - `\"INCLUSION\"` - `{{> foo}}`\n// - `\"BLOCKOPEN\"` - `{{#foo}}`\n// - `\"BLOCKCLOSE\"` - `{{/foo}}`\n// - `\"ELSE\"` - `{{else}}`\n// - `\"ESCAPE\"` - `{{|`, `{{{|`, `{{{{|` and so on\n//\n// Besides `type`, the mandatory properties of a TemplateTag are:\n//\n// - `path` - An array of one or more strings.  The path of `{{foo.bar}}`\n//   is `[\"foo\", \"bar\"]`.  Applies to DOUBLE, TRIPLE, INCLUSION, BLOCKOPEN,\n//   BLOCKCLOSE, and ELSE.\n//\n// - `args` - An array of zero or more argument specs.  An argument spec\n//   is a two or three element array, consisting of a type, value, and\n//   optional keyword name.  For example, the `args` of `{{foo \"bar\" x=3}}`\n//   are `[[\"STRING\", \"bar\"], [\"NUMBER\", 3, \"x\"]]`.  Applies to DOUBLE,\n//   TRIPLE, INCLUSION, BLOCKOPEN, and ELSE.\n//\n// - `value` - A string of the comment's text. Applies to COMMENT and\n//   BLOCKCOMMENT.\n//\n// These additional are typically set during parsing:\n//\n// - `position` - The HTMLTools.TEMPLATE_TAG_POSITION specifying at what sort\n//   of site the TemplateTag was encountered (e.g. at element level or as\n//   part of an attribute value). Its absence implies\n//   TEMPLATE_TAG_POSITION.ELEMENT.\n//\n// - `content` and `elseContent` - When a BLOCKOPEN tag's contents are\n//   parsed, they are put here.  `elseContent` will only be present if\n//   an `{{else}}` was found.\nvar TEMPLATE_TAG_POSITION = HTMLTools.TEMPLATE_TAG_POSITION;\n\nfunction TemplateTag() {\n  HTMLTools.TemplateTag.apply(this, arguments);\n}\n\nTemplateTag.prototype = new HTMLTools.TemplateTag();\nTemplateTag.prototype.constructorName = 'SpacebarsCompiler.TemplateTag';\n\nvar makeStacheTagStartRegex = function (r) {\n  return new RegExp(r.source + /(?![{>!#/])/.source, r.ignoreCase ? 'i' : '');\n}; // \"starts\" regexes are used to see what type of template\n// tag the parser is looking at.  They must match a non-empty\n// result, but not the interesting part of the tag.\n\n\nvar starts = {\n  ESCAPE: /^\\{\\{(?=\\{*\\|)/,\n  ELSE: makeStacheTagStartRegex(/^\\{\\{\\s*else(\\s+(?!\\s)|(?=[}]))/i),\n  DOUBLE: makeStacheTagStartRegex(/^\\{\\{\\s*(?!\\s)/),\n  TRIPLE: makeStacheTagStartRegex(/^\\{\\{\\{\\s*(?!\\s)/),\n  BLOCKCOMMENT: makeStacheTagStartRegex(/^\\{\\{\\s*!--/),\n  COMMENT: makeStacheTagStartRegex(/^\\{\\{\\s*!/),\n  INCLUSION: makeStacheTagStartRegex(/^\\{\\{\\s*>\\s*(?!\\s)/),\n  BLOCKOPEN: makeStacheTagStartRegex(/^\\{\\{\\s*#\\s*(?!\\s)/),\n  BLOCKCLOSE: makeStacheTagStartRegex(/^\\{\\{\\s*\\/\\s*(?!\\s)/)\n};\nvar ends = {\n  DOUBLE: /^\\s*\\}\\}/,\n  TRIPLE: /^\\s*\\}\\}\\}/,\n  EXPR: /^\\s*\\)/\n};\nvar endsString = {\n  DOUBLE: '}}',\n  TRIPLE: '}}}',\n  EXPR: ')'\n}; // Parse a tag from the provided scanner or string.  If the input\n// doesn't start with `{{`, returns null.  Otherwise, either succeeds\n// and returns a SpacebarsCompiler.TemplateTag, or throws an error (using\n// `scanner.fatal` if a scanner is provided).\n\nTemplateTag.parse = function (scannerOrString) {\n  var scanner = scannerOrString;\n  if (typeof scanner === 'string') scanner = new HTMLTools.Scanner(scannerOrString);\n  if (!(scanner.peek() === '{' && scanner.rest().slice(0, 2) === '{{')) return null;\n\n  var run = function (regex) {\n    // regex is assumed to start with `^`\n    var result = regex.exec(scanner.rest());\n    if (!result) return null;\n    var ret = result[0];\n    scanner.pos += ret.length;\n    return ret;\n  };\n\n  var advance = function (amount) {\n    scanner.pos += amount;\n  };\n\n  var scanIdentifier = function (isFirstInPath) {\n    var id = BlazeTools.parseExtendedIdentifierName(scanner);\n\n    if (!id) {\n      expected('IDENTIFIER');\n    }\n\n    if (isFirstInPath && (id === 'null' || id === 'true' || id === 'false')) scanner.fatal(\"Can't use null, true, or false, as an identifier at start of path\");\n    return id;\n  };\n\n  var scanPath = function () {\n    var segments = []; // handle initial `.`, `..`, `./`, `../`, `../..`, `../../`, etc\n\n    var dots;\n\n    if (dots = run(/^[\\.\\/]+/)) {\n      var ancestorStr = '.'; // eg `../../..` maps to `....`\n\n      var endsWithSlash = /\\/$/.test(dots);\n      if (endsWithSlash) dots = dots.slice(0, -1);\n\n      _.each(dots.split('/'), function (dotClause, index) {\n        if (index === 0) {\n          if (dotClause !== '.' && dotClause !== '..') expected(\"`.`, `..`, `./` or `../`\");\n        } else {\n          if (dotClause !== '..') expected(\"`..` or `../`\");\n        }\n\n        if (dotClause === '..') ancestorStr += '.';\n      });\n\n      segments.push(ancestorStr);\n      if (!endsWithSlash) return segments;\n    }\n\n    while (true) {\n      // scan a path segment\n      if (run(/^\\[/)) {\n        var seg = run(/^[\\s\\S]*?\\]/);\n        if (!seg) error(\"Unterminated path segment\");\n        seg = seg.slice(0, -1);\n        if (!seg && !segments.length) error(\"Path can't start with empty string\");\n        segments.push(seg);\n      } else {\n        var id = scanIdentifier(!segments.length);\n\n        if (id === 'this') {\n          if (!segments.length) {\n            // initial `this`\n            segments.push('.');\n          } else {\n            error(\"Can only use `this` at the beginning of a path.\\nInstead of `foo.this` or `../this`, just write `foo` or `..`.\");\n          }\n        } else {\n          segments.push(id);\n        }\n      }\n\n      var sep = run(/^[\\.\\/]/);\n      if (!sep) break;\n    }\n\n    return segments;\n  }; // scan the keyword portion of a keyword argument\n  // (the \"foo\" portion in \"foo=bar\").\n  // Result is either the keyword matched, or null\n  // if we're not at a keyword argument position.\n\n\n  var scanArgKeyword = function () {\n    var match = /^([^\\{\\}\\(\\)\\>#=\\s\"'\\[\\]]+)\\s*=\\s*/.exec(scanner.rest());\n\n    if (match) {\n      scanner.pos += match[0].length;\n      return match[1];\n    } else {\n      return null;\n    }\n  }; // scan an argument; succeeds or errors.\n  // Result is an array of two or three items:\n  // type , value, and (indicating a keyword argument)\n  // keyword name.\n\n\n  var scanArg = function () {\n    var keyword = scanArgKeyword(); // null if not parsing a kwarg\n\n    var value = scanArgValue();\n    return keyword ? value.concat(keyword) : value;\n  }; // scan an argument value (for keyword or positional arguments);\n  // succeeds or errors.  Result is an array of type, value.\n\n\n  var scanArgValue = function () {\n    var startPos = scanner.pos;\n    var result;\n\n    if (result = BlazeTools.parseNumber(scanner)) {\n      return ['NUMBER', result.value];\n    } else if (result = BlazeTools.parseStringLiteral(scanner)) {\n      return ['STRING', result.value];\n    } else if (/^[\\.\\[]/.test(scanner.peek())) {\n      return ['PATH', scanPath()];\n    } else if (run(/^\\(/)) {\n      return ['EXPR', scanExpr('EXPR')];\n    } else if (result = BlazeTools.parseExtendedIdentifierName(scanner)) {\n      var id = result;\n\n      if (id === 'null') {\n        return ['NULL', null];\n      } else if (id === 'true' || id === 'false') {\n        return ['BOOLEAN', id === 'true'];\n      } else {\n        scanner.pos = startPos; // unconsume `id`\n\n        return ['PATH', scanPath()];\n      }\n    } else {\n      expected('identifier, number, string, boolean, null, or a sub expression enclosed in \"(\", \")\"');\n    }\n  };\n\n  var scanExpr = function (type) {\n    var endType = type;\n    if (type === 'INCLUSION' || type === 'BLOCKOPEN' || type === 'ELSE') endType = 'DOUBLE';\n    var tag = new TemplateTag();\n    tag.type = type;\n    tag.path = scanPath();\n    tag.args = [];\n    var foundKwArg = false;\n\n    while (true) {\n      run(/^\\s*/);\n      if (run(ends[endType])) break;else if (/^[})]/.test(scanner.peek())) {\n        expected('`' + endsString[endType] + '`');\n      }\n      var newArg = scanArg();\n\n      if (newArg.length === 3) {\n        foundKwArg = true;\n      } else {\n        if (foundKwArg) error(\"Can't have a non-keyword argument after a keyword argument\");\n      }\n\n      tag.args.push(newArg); // expect a whitespace or a closing ')' or '}'\n\n      if (run(/^(?=[\\s})])/) !== '') expected('space');\n    }\n\n    return tag;\n  };\n\n  var type;\n\n  var error = function (msg) {\n    scanner.fatal(msg);\n  };\n\n  var expected = function (what) {\n    error('Expected ' + what);\n  }; // must do ESCAPE first, immediately followed by ELSE\n  // order of others doesn't matter\n\n\n  if (run(starts.ESCAPE)) type = 'ESCAPE';else if (run(starts.ELSE)) type = 'ELSE';else if (run(starts.DOUBLE)) type = 'DOUBLE';else if (run(starts.TRIPLE)) type = 'TRIPLE';else if (run(starts.BLOCKCOMMENT)) type = 'BLOCKCOMMENT';else if (run(starts.COMMENT)) type = 'COMMENT';else if (run(starts.INCLUSION)) type = 'INCLUSION';else if (run(starts.BLOCKOPEN)) type = 'BLOCKOPEN';else if (run(starts.BLOCKCLOSE)) type = 'BLOCKCLOSE';else error('Unknown stache tag');\n  var tag = new TemplateTag();\n  tag.type = type;\n\n  if (type === 'BLOCKCOMMENT') {\n    var result = run(/^[\\s\\S]*?--\\s*?\\}\\}/);\n    if (!result) error(\"Unclosed block comment\");\n    tag.value = result.slice(0, result.lastIndexOf('--'));\n  } else if (type === 'COMMENT') {\n    var result = run(/^[\\s\\S]*?\\}\\}/);\n    if (!result) error(\"Unclosed comment\");\n    tag.value = result.slice(0, -2);\n  } else if (type === 'BLOCKCLOSE') {\n    tag.path = scanPath();\n    if (!run(ends.DOUBLE)) expected('`}}`');\n  } else if (type === 'ELSE') {\n    if (!run(ends.DOUBLE)) {\n      tag = scanExpr(type);\n    }\n  } else if (type === 'ESCAPE') {\n    var result = run(/^\\{*\\|/);\n    tag.value = '{{' + result.slice(0, -1);\n  } else {\n    // DOUBLE, TRIPLE, BLOCKOPEN, INCLUSION\n    tag = scanExpr(type);\n  }\n\n  return tag;\n}; // Returns a SpacebarsCompiler.TemplateTag parsed from `scanner`, leaving scanner\n// at its original position.\n//\n// An error will still be thrown if there is not a valid template tag at\n// the current position.\n\n\nTemplateTag.peek = function (scanner) {\n  var startPos = scanner.pos;\n  var result = TemplateTag.parse(scanner);\n  scanner.pos = startPos;\n  return result;\n}; // Like `TemplateTag.parse`, but in the case of blocks, parse the complete\n// `{{#foo}}...{{/foo}}` with `content` and possible `elseContent`, rather\n// than just the BLOCKOPEN tag.\n//\n// In addition:\n//\n// - Throws an error if `{{else}}` or `{{/foo}}` tag is encountered.\n//\n// - Returns `null` for a COMMENT.  (This case is distinguishable from\n//   parsing no tag by the fact that the scanner is advanced.)\n//\n// - Takes an HTMLTools.TEMPLATE_TAG_POSITION `position` and sets it as the\n//   TemplateTag's `.position` property.\n//\n// - Validates the tag's well-formedness and legality at in its position.\n\n\nTemplateTag.parseCompleteTag = function (scannerOrString, position) {\n  var scanner = scannerOrString;\n  if (typeof scanner === 'string') scanner = new HTMLTools.Scanner(scannerOrString);\n  var startPos = scanner.pos; // for error messages\n\n  var result = TemplateTag.parse(scannerOrString);\n  if (!result) return result;\n  if (result.type === 'BLOCKCOMMENT') return null;\n  if (result.type === 'COMMENT') return null;\n  if (result.type === 'ELSE') scanner.fatal(\"Unexpected {{else}}\");\n  if (result.type === 'BLOCKCLOSE') scanner.fatal(\"Unexpected closing template tag\");\n  position = position || TEMPLATE_TAG_POSITION.ELEMENT;\n  if (position !== TEMPLATE_TAG_POSITION.ELEMENT) result.position = position;\n\n  if (result.type === 'BLOCKOPEN') {\n    // parse block contents\n    // Construct a string version of `.path` for comparing start and\n    // end tags.  For example, `foo/[0]` was parsed into `[\"foo\", \"0\"]`\n    // and now becomes `foo,0`.  This form may also show up in error\n    // messages.\n    var blockName = result.path.join(',');\n    var textMode = null;\n\n    if (blockName === 'markdown' || position === TEMPLATE_TAG_POSITION.IN_RAWTEXT) {\n      textMode = HTML.TEXTMODE.STRING;\n    } else if (position === TEMPLATE_TAG_POSITION.IN_RCDATA || position === TEMPLATE_TAG_POSITION.IN_ATTRIBUTE) {\n      textMode = HTML.TEXTMODE.RCDATA;\n    }\n\n    var parserOptions = {\n      getTemplateTag: TemplateTag.parseCompleteTag,\n      shouldStop: isAtBlockCloseOrElse,\n      textMode: textMode\n    };\n    result.textMode = textMode;\n    result.content = HTMLTools.parseFragment(scanner, parserOptions);\n    if (scanner.rest().slice(0, 2) !== '{{') scanner.fatal(\"Expected {{else}} or block close for \" + blockName);\n    var lastPos = scanner.pos; // save for error messages\n\n    var tmplTag = TemplateTag.parse(scanner); // {{else}} or {{/foo}}\n\n    var lastElseContentTag = result;\n\n    while (tmplTag.type === 'ELSE') {\n      if (lastElseContentTag === null) {\n        scanner.fatal(\"Unexpected else after {{else}}\");\n      }\n\n      if (tmplTag.path) {\n        lastElseContentTag.elseContent = new TemplateTag();\n        lastElseContentTag.elseContent.type = 'BLOCKOPEN';\n        lastElseContentTag.elseContent.path = tmplTag.path;\n        lastElseContentTag.elseContent.args = tmplTag.args;\n        lastElseContentTag.elseContent.textMode = textMode;\n        lastElseContentTag.elseContent.content = HTMLTools.parseFragment(scanner, parserOptions);\n        lastElseContentTag = lastElseContentTag.elseContent;\n      } else {\n        // parse {{else}} and content up to close tag\n        lastElseContentTag.elseContent = HTMLTools.parseFragment(scanner, parserOptions);\n        lastElseContentTag = null;\n      }\n\n      if (scanner.rest().slice(0, 2) !== '{{') scanner.fatal(\"Expected block close for \" + blockName);\n      lastPos = scanner.pos;\n      tmplTag = TemplateTag.parse(scanner);\n    }\n\n    if (tmplTag.type === 'BLOCKCLOSE') {\n      var blockName2 = tmplTag.path.join(',');\n\n      if (blockName !== blockName2) {\n        scanner.pos = lastPos;\n        scanner.fatal('Expected tag to close ' + blockName + ', found ' + blockName2);\n      }\n    } else {\n      scanner.pos = lastPos;\n      scanner.fatal('Expected tag to close ' + blockName + ', found ' + tmplTag.type);\n    }\n  }\n\n  var finalPos = scanner.pos;\n  scanner.pos = startPos;\n  validateTag(result, scanner);\n  scanner.pos = finalPos;\n  return result;\n};\n\nvar isAtBlockCloseOrElse = function (scanner) {\n  // Detect `{{else}}` or `{{/foo}}`.\n  //\n  // We do as much work ourselves before deferring to `TemplateTag.peek`,\n  // for efficiency (we're called for every input token) and to be\n  // less obtrusive, because `TemplateTag.peek` will throw an error if it\n  // sees `{{` followed by a malformed tag.\n  var rest, type;\n  return scanner.peek() === '{' && (rest = scanner.rest()).slice(0, 2) === '{{' && /^\\{\\{\\s*(\\/|else\\b)/.test(rest) && (type = TemplateTag.peek(scanner).type) && (type === 'BLOCKCLOSE' || type === 'ELSE');\n}; // Validate that `templateTag` is correctly formed and legal for its\n// HTML position.  Use `scanner` to report errors. On success, does\n// nothing.\n\n\nvar validateTag = function (ttag, scanner) {\n  if (ttag.type === 'INCLUSION' || ttag.type === 'BLOCKOPEN') {\n    var args = ttag.args;\n\n    if (ttag.path[0] === 'each' && args[1] && args[1][0] === 'PATH' && args[1][1][0] === 'in') {// For slightly better error messages, we detect the each-in case\n      // here in order not to complain if the user writes `{{#each 3 in x}}`\n      // that \"3 is not a function\"\n    } else {\n      if (args.length > 1 && args[0].length === 2 && args[0][0] !== 'PATH') {\n        // we have a positional argument that is not a PATH followed by\n        // other arguments\n        scanner.fatal(\"First argument must be a function, to be called on \" + \"the rest of the arguments; found \" + args[0][0]);\n      }\n    }\n  }\n\n  var position = ttag.position || TEMPLATE_TAG_POSITION.ELEMENT;\n\n  if (position === TEMPLATE_TAG_POSITION.IN_ATTRIBUTE) {\n    if (ttag.type === 'DOUBLE' || ttag.type === 'ESCAPE') {\n      return;\n    } else if (ttag.type === 'BLOCKOPEN') {\n      var path = ttag.path;\n      var path0 = path[0];\n\n      if (!(path.length === 1 && (path0 === 'if' || path0 === 'unless' || path0 === 'with' || path0 === 'each'))) {\n        scanner.fatal(\"Custom block helpers are not allowed in an HTML attribute, only built-in ones like #each and #if\");\n      }\n    } else {\n      scanner.fatal(ttag.type + \" template tag is not allowed in an HTML attribute\");\n    }\n  } else if (position === TEMPLATE_TAG_POSITION.IN_START_TAG) {\n    if (!(ttag.type === 'DOUBLE')) {\n      scanner.fatal(\"Reactive HTML attributes must either have a constant name or consist of a single {{helper}} providing a dictionary of names and values.  A template tag of type \" + ttag.type + \" is not allowed here.\");\n    }\n\n    if (scanner.peek() === '=') {\n      scanner.fatal(\"Template tags are not allowed in attribute names, only in attribute values or in the form of a single {{helper}} that evaluates to a dictionary of name=value pairs.\");\n    }\n  }\n};","map":{"version":3,"sources":["packages/spacebars-compiler/templatetag.js"],"names":["module","export","TemplateTag","HTMLTools","link","v","HTML","BlazeTools","TEMPLATE_TAG_POSITION","apply","arguments","prototype","constructorName","makeStacheTagStartRegex","r","RegExp","source","ignoreCase","starts","ESCAPE","ELSE","DOUBLE","TRIPLE","BLOCKCOMMENT","COMMENT","INCLUSION","BLOCKOPEN","BLOCKCLOSE","ends","EXPR","endsString","parse","scannerOrString","scanner","Scanner","peek","rest","slice","run","regex","result","exec","ret","pos","length","advance","amount","scanIdentifier","isFirstInPath","id","parseExtendedIdentifierName","expected","fatal","scanPath","segments","dots","ancestorStr","endsWithSlash","test","_","each","split","dotClause","index","push","seg","error","sep","scanArgKeyword","match","scanArg","keyword","value","scanArgValue","concat","startPos","parseNumber","parseStringLiteral","scanExpr","type","endType","tag","path","args","foundKwArg","newArg","msg","what","lastIndexOf","parseCompleteTag","position","ELEMENT","blockName","join","textMode","IN_RAWTEXT","TEXTMODE","STRING","IN_RCDATA","IN_ATTRIBUTE","RCDATA","parserOptions","getTemplateTag","shouldStop","isAtBlockCloseOrElse","content","parseFragment","lastPos","tmplTag","lastElseContentTag","elseContent","blockName2","finalPos","validateTag","ttag","path0","IN_START_TAG"],"mappings":"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","sourcesContent":["import { HTMLTools } from 'meteor/html-tools';\nimport { HTML } from 'meteor/htmljs';\nimport { BlazeTools } from 'meteor/blaze-tools';\n\n// A TemplateTag is the result of parsing a single `{{...}}` tag.\n//\n// The `.type` of a TemplateTag is one of:\n//\n// - `\"DOUBLE\"` - `{{foo}}`\n// - `\"TRIPLE\"` - `{{{foo}}}`\n// - `\"EXPR\"` - `(foo)`\n// - `\"COMMENT\"` - `{{! foo}}`\n// - `\"BLOCKCOMMENT\" - `{{!-- foo--}}`\n// - `\"INCLUSION\"` - `{{> foo}}`\n// - `\"BLOCKOPEN\"` - `{{#foo}}`\n// - `\"BLOCKCLOSE\"` - `{{/foo}}`\n// - `\"ELSE\"` - `{{else}}`\n// - `\"ESCAPE\"` - `{{|`, `{{{|`, `{{{{|` and so on\n//\n// Besides `type`, the mandatory properties of a TemplateTag are:\n//\n// - `path` - An array of one or more strings.  The path of `{{foo.bar}}`\n//   is `[\"foo\", \"bar\"]`.  Applies to DOUBLE, TRIPLE, INCLUSION, BLOCKOPEN,\n//   BLOCKCLOSE, and ELSE.\n//\n// - `args` - An array of zero or more argument specs.  An argument spec\n//   is a two or three element array, consisting of a type, value, and\n//   optional keyword name.  For example, the `args` of `{{foo \"bar\" x=3}}`\n//   are `[[\"STRING\", \"bar\"], [\"NUMBER\", 3, \"x\"]]`.  Applies to DOUBLE,\n//   TRIPLE, INCLUSION, BLOCKOPEN, and ELSE.\n//\n// - `value` - A string of the comment's text. Applies to COMMENT and\n//   BLOCKCOMMENT.\n//\n// These additional are typically set during parsing:\n//\n// - `position` - The HTMLTools.TEMPLATE_TAG_POSITION specifying at what sort\n//   of site the TemplateTag was encountered (e.g. at element level or as\n//   part of an attribute value). Its absence implies\n//   TEMPLATE_TAG_POSITION.ELEMENT.\n//\n// - `content` and `elseContent` - When a BLOCKOPEN tag's contents are\n//   parsed, they are put here.  `elseContent` will only be present if\n//   an `{{else}}` was found.\n\nvar TEMPLATE_TAG_POSITION = HTMLTools.TEMPLATE_TAG_POSITION;\n\nexport function TemplateTag () {\n  HTMLTools.TemplateTag.apply(this, arguments);\n}\n\nTemplateTag.prototype = new HTMLTools.TemplateTag;\nTemplateTag.prototype.constructorName = 'SpacebarsCompiler.TemplateTag';\n\nvar makeStacheTagStartRegex = function (r) {\n  return new RegExp(r.source + /(?![{>!#/])/.source,\n                    r.ignoreCase ? 'i' : '');\n};\n\n// \"starts\" regexes are used to see what type of template\n// tag the parser is looking at.  They must match a non-empty\n// result, but not the interesting part of the tag.\nvar starts = {\n  ESCAPE: /^\\{\\{(?=\\{*\\|)/,\n  ELSE: makeStacheTagStartRegex(/^\\{\\{\\s*else(\\s+(?!\\s)|(?=[}]))/i),\n  DOUBLE: makeStacheTagStartRegex(/^\\{\\{\\s*(?!\\s)/),\n  TRIPLE: makeStacheTagStartRegex(/^\\{\\{\\{\\s*(?!\\s)/),\n  BLOCKCOMMENT: makeStacheTagStartRegex(/^\\{\\{\\s*!--/),\n  COMMENT: makeStacheTagStartRegex(/^\\{\\{\\s*!/),\n  INCLUSION: makeStacheTagStartRegex(/^\\{\\{\\s*>\\s*(?!\\s)/),\n  BLOCKOPEN: makeStacheTagStartRegex(/^\\{\\{\\s*#\\s*(?!\\s)/),\n  BLOCKCLOSE: makeStacheTagStartRegex(/^\\{\\{\\s*\\/\\s*(?!\\s)/)\n};\n\nvar ends = {\n  DOUBLE: /^\\s*\\}\\}/,\n  TRIPLE: /^\\s*\\}\\}\\}/,\n  EXPR: /^\\s*\\)/\n};\n\nvar endsString = {\n  DOUBLE: '}}',\n  TRIPLE: '}}}',\n  EXPR: ')'\n};\n\n// Parse a tag from the provided scanner or string.  If the input\n// doesn't start with `{{`, returns null.  Otherwise, either succeeds\n// and returns a SpacebarsCompiler.TemplateTag, or throws an error (using\n// `scanner.fatal` if a scanner is provided).\nTemplateTag.parse = function (scannerOrString) {\n  var scanner = scannerOrString;\n  if (typeof scanner === 'string')\n    scanner = new HTMLTools.Scanner(scannerOrString);\n\n  if (! (scanner.peek() === '{' &&\n         (scanner.rest()).slice(0, 2) === '{{'))\n    return null;\n\n  var run = function (regex) {\n    // regex is assumed to start with `^`\n    var result = regex.exec(scanner.rest());\n    if (! result)\n      return null;\n    var ret = result[0];\n    scanner.pos += ret.length;\n    return ret;\n  };\n\n  var advance = function (amount) {\n    scanner.pos += amount;\n  };\n\n  var scanIdentifier = function (isFirstInPath) {\n    var id = BlazeTools.parseExtendedIdentifierName(scanner);\n    if (! id) {\n      expected('IDENTIFIER');\n    }\n    if (isFirstInPath &&\n        (id === 'null' || id === 'true' || id === 'false'))\n      scanner.fatal(\"Can't use null, true, or false, as an identifier at start of path\");\n\n    return id;\n  };\n\n  var scanPath = function () {\n    var segments = [];\n\n    // handle initial `.`, `..`, `./`, `../`, `../..`, `../../`, etc\n    var dots;\n    if ((dots = run(/^[\\.\\/]+/))) {\n      var ancestorStr = '.'; // eg `../../..` maps to `....`\n      var endsWithSlash = /\\/$/.test(dots);\n\n      if (endsWithSlash)\n        dots = dots.slice(0, -1);\n\n      _.each(dots.split('/'), function(dotClause, index) {\n        if (index === 0) {\n          if (dotClause !== '.' && dotClause !== '..')\n            expected(\"`.`, `..`, `./` or `../`\");\n        } else {\n          if (dotClause !== '..')\n            expected(\"`..` or `../`\");\n        }\n\n        if (dotClause === '..')\n          ancestorStr += '.';\n      });\n\n      segments.push(ancestorStr);\n\n      if (!endsWithSlash)\n        return segments;\n    }\n\n    while (true) {\n      // scan a path segment\n\n      if (run(/^\\[/)) {\n        var seg = run(/^[\\s\\S]*?\\]/);\n        if (! seg)\n          error(\"Unterminated path segment\");\n        seg = seg.slice(0, -1);\n        if (! seg && ! segments.length)\n          error(\"Path can't start with empty string\");\n        segments.push(seg);\n      } else {\n        var id = scanIdentifier(! segments.length);\n        if (id === 'this') {\n          if (! segments.length) {\n            // initial `this`\n            segments.push('.');\n          } else {\n            error(\"Can only use `this` at the beginning of a path.\\nInstead of `foo.this` or `../this`, just write `foo` or `..`.\");\n          }\n        } else {\n          segments.push(id);\n        }\n      }\n\n      var sep = run(/^[\\.\\/]/);\n      if (! sep)\n        break;\n    }\n\n    return segments;\n  };\n\n  // scan the keyword portion of a keyword argument\n  // (the \"foo\" portion in \"foo=bar\").\n  // Result is either the keyword matched, or null\n  // if we're not at a keyword argument position.\n  var scanArgKeyword = function () {\n    var match = /^([^\\{\\}\\(\\)\\>#=\\s\"'\\[\\]]+)\\s*=\\s*/.exec(scanner.rest());\n    if (match) {\n      scanner.pos += match[0].length;\n      return match[1];\n    } else {\n      return null;\n    }\n  };\n\n  // scan an argument; succeeds or errors.\n  // Result is an array of two or three items:\n  // type , value, and (indicating a keyword argument)\n  // keyword name.\n  var scanArg = function () {\n    var keyword = scanArgKeyword(); // null if not parsing a kwarg\n    var value = scanArgValue();\n    return keyword ? value.concat(keyword) : value;\n  };\n\n  // scan an argument value (for keyword or positional arguments);\n  // succeeds or errors.  Result is an array of type, value.\n  var scanArgValue = function () {\n    var startPos = scanner.pos;\n    var result;\n    if ((result = BlazeTools.parseNumber(scanner))) {\n      return ['NUMBER', result.value];\n    } else if ((result = BlazeTools.parseStringLiteral(scanner))) {\n      return ['STRING', result.value];\n    } else if (/^[\\.\\[]/.test(scanner.peek())) {\n      return ['PATH', scanPath()];\n    } else if (run(/^\\(/)) {\n      return ['EXPR', scanExpr('EXPR')];\n    } else if ((result = BlazeTools.parseExtendedIdentifierName(scanner))) {\n      var id = result;\n      if (id === 'null') {\n        return ['NULL', null];\n      } else if (id === 'true' || id === 'false') {\n        return ['BOOLEAN', id === 'true'];\n      } else {\n        scanner.pos = startPos; // unconsume `id`\n        return ['PATH', scanPath()];\n      }\n    } else {\n      expected('identifier, number, string, boolean, null, or a sub expression enclosed in \"(\", \")\"');\n    }\n  };\n\n  var scanExpr = function (type) {\n    var endType = type;\n    if (type === 'INCLUSION' || type === 'BLOCKOPEN' || type === 'ELSE')\n      endType = 'DOUBLE';\n\n    var tag = new TemplateTag;\n    tag.type = type;\n    tag.path = scanPath();\n    tag.args = [];\n    var foundKwArg = false;\n    while (true) {\n      run(/^\\s*/);\n      if (run(ends[endType]))\n        break;\n      else if (/^[})]/.test(scanner.peek())) {\n        expected('`' + endsString[endType] + '`');\n      }\n      var newArg = scanArg();\n      if (newArg.length === 3) {\n        foundKwArg = true;\n      } else {\n        if (foundKwArg)\n          error(\"Can't have a non-keyword argument after a keyword argument\");\n      }\n      tag.args.push(newArg);\n\n      // expect a whitespace or a closing ')' or '}'\n      if (run(/^(?=[\\s})])/) !== '')\n        expected('space');\n    }\n\n    return tag;\n  };\n\n  var type;\n\n  var error = function (msg) {\n    scanner.fatal(msg);\n  };\n\n  var expected = function (what) {\n    error('Expected ' + what);\n  };\n\n  // must do ESCAPE first, immediately followed by ELSE\n  // order of others doesn't matter\n  if (run(starts.ESCAPE)) type = 'ESCAPE';\n  else if (run(starts.ELSE)) type = 'ELSE';\n  else if (run(starts.DOUBLE)) type = 'DOUBLE';\n  else if (run(starts.TRIPLE)) type = 'TRIPLE';\n  else if (run(starts.BLOCKCOMMENT)) type = 'BLOCKCOMMENT';\n  else if (run(starts.COMMENT)) type = 'COMMENT';\n  else if (run(starts.INCLUSION)) type = 'INCLUSION';\n  else if (run(starts.BLOCKOPEN)) type = 'BLOCKOPEN';\n  else if (run(starts.BLOCKCLOSE)) type = 'BLOCKCLOSE';\n  else\n    error('Unknown stache tag');\n\n  var tag = new TemplateTag;\n  tag.type = type;\n\n  if (type === 'BLOCKCOMMENT') {\n    var result = run(/^[\\s\\S]*?--\\s*?\\}\\}/);\n    if (! result)\n      error(\"Unclosed block comment\");\n    tag.value = result.slice(0, result.lastIndexOf('--'));\n  } else if (type === 'COMMENT') {\n    var result = run(/^[\\s\\S]*?\\}\\}/);\n    if (! result)\n      error(\"Unclosed comment\");\n    tag.value = result.slice(0, -2);\n  } else if (type === 'BLOCKCLOSE') {\n    tag.path = scanPath();\n    if (! run(ends.DOUBLE))\n      expected('`}}`');\n  } else if (type === 'ELSE') {\n    if (! run(ends.DOUBLE)) {\n      tag = scanExpr(type);\n    }\n  } else if (type === 'ESCAPE') {\n    var result = run(/^\\{*\\|/);\n    tag.value = '{{' + result.slice(0, -1);\n  } else {\n    // DOUBLE, TRIPLE, BLOCKOPEN, INCLUSION\n    tag = scanExpr(type);\n  }\n\n  return tag;\n};\n\n// Returns a SpacebarsCompiler.TemplateTag parsed from `scanner`, leaving scanner\n// at its original position.\n//\n// An error will still be thrown if there is not a valid template tag at\n// the current position.\nTemplateTag.peek = function (scanner) {\n  var startPos = scanner.pos;\n  var result = TemplateTag.parse(scanner);\n  scanner.pos = startPos;\n  return result;\n};\n\n// Like `TemplateTag.parse`, but in the case of blocks, parse the complete\n// `{{#foo}}...{{/foo}}` with `content` and possible `elseContent`, rather\n// than just the BLOCKOPEN tag.\n//\n// In addition:\n//\n// - Throws an error if `{{else}}` or `{{/foo}}` tag is encountered.\n//\n// - Returns `null` for a COMMENT.  (This case is distinguishable from\n//   parsing no tag by the fact that the scanner is advanced.)\n//\n// - Takes an HTMLTools.TEMPLATE_TAG_POSITION `position` and sets it as the\n//   TemplateTag's `.position` property.\n//\n// - Validates the tag's well-formedness and legality at in its position.\nTemplateTag.parseCompleteTag = function (scannerOrString, position) {\n  var scanner = scannerOrString;\n  if (typeof scanner === 'string')\n    scanner = new HTMLTools.Scanner(scannerOrString);\n\n  var startPos = scanner.pos; // for error messages\n  var result = TemplateTag.parse(scannerOrString);\n  if (! result)\n    return result;\n\n  if (result.type === 'BLOCKCOMMENT')\n    return null;\n\n  if (result.type === 'COMMENT')\n    return null;\n\n  if (result.type === 'ELSE')\n    scanner.fatal(\"Unexpected {{else}}\");\n\n  if (result.type === 'BLOCKCLOSE')\n    scanner.fatal(\"Unexpected closing template tag\");\n\n  position = (position || TEMPLATE_TAG_POSITION.ELEMENT);\n  if (position !== TEMPLATE_TAG_POSITION.ELEMENT)\n    result.position = position;\n\n  if (result.type === 'BLOCKOPEN') {\n    // parse block contents\n\n    // Construct a string version of `.path` for comparing start and\n    // end tags.  For example, `foo/[0]` was parsed into `[\"foo\", \"0\"]`\n    // and now becomes `foo,0`.  This form may also show up in error\n    // messages.\n    var blockName = result.path.join(',');\n\n    var textMode = null;\n      if (blockName === 'markdown' ||\n          position === TEMPLATE_TAG_POSITION.IN_RAWTEXT) {\n        textMode = HTML.TEXTMODE.STRING;\n      } else if (position === TEMPLATE_TAG_POSITION.IN_RCDATA ||\n                 position === TEMPLATE_TAG_POSITION.IN_ATTRIBUTE) {\n        textMode = HTML.TEXTMODE.RCDATA;\n      }\n      var parserOptions = {\n        getTemplateTag: TemplateTag.parseCompleteTag,\n        shouldStop: isAtBlockCloseOrElse,\n        textMode: textMode\n      };\n    result.textMode = textMode;\n    result.content = HTMLTools.parseFragment(scanner, parserOptions);\n\n    if (scanner.rest().slice(0, 2) !== '{{')\n      scanner.fatal(\"Expected {{else}} or block close for \" + blockName);\n\n    var lastPos = scanner.pos; // save for error messages\n    var tmplTag = TemplateTag.parse(scanner); // {{else}} or {{/foo}}\n\n    var lastElseContentTag = result;\n    while (tmplTag.type === 'ELSE') {\n      if (lastElseContentTag === null) {\n        scanner.fatal(\"Unexpected else after {{else}}\");\n      }\n\n      if (tmplTag.path) {\n        lastElseContentTag.elseContent = new TemplateTag;\n        lastElseContentTag.elseContent.type = 'BLOCKOPEN';\n        lastElseContentTag.elseContent.path = tmplTag.path;\n        lastElseContentTag.elseContent.args = tmplTag.args;\n        lastElseContentTag.elseContent.textMode = textMode;\n        lastElseContentTag.elseContent.content = HTMLTools.parseFragment(scanner, parserOptions);\n\n        lastElseContentTag = lastElseContentTag.elseContent;\n      }\n      else {\n        // parse {{else}} and content up to close tag\n        lastElseContentTag.elseContent = HTMLTools.parseFragment(scanner, parserOptions);\n\n        lastElseContentTag = null;\n      }\n\n      if (scanner.rest().slice(0, 2) !== '{{')\n        scanner.fatal(\"Expected block close for \" + blockName);\n\n      lastPos = scanner.pos;\n      tmplTag = TemplateTag.parse(scanner);\n    }\n\n    if (tmplTag.type === 'BLOCKCLOSE') {\n      var blockName2 = tmplTag.path.join(',');\n      if (blockName !== blockName2) {\n        scanner.pos = lastPos;\n        scanner.fatal('Expected tag to close ' + blockName + ', found ' +\n                      blockName2);\n      }\n    } else {\n      scanner.pos = lastPos;\n      scanner.fatal('Expected tag to close ' + blockName + ', found ' +\n                    tmplTag.type);\n    }\n  }\n\n  var finalPos = scanner.pos;\n  scanner.pos = startPos;\n  validateTag(result, scanner);\n  scanner.pos = finalPos;\n\n  return result;\n};\n\nvar isAtBlockCloseOrElse = function (scanner) {\n  // Detect `{{else}}` or `{{/foo}}`.\n  //\n  // We do as much work ourselves before deferring to `TemplateTag.peek`,\n  // for efficiency (we're called for every input token) and to be\n  // less obtrusive, because `TemplateTag.peek` will throw an error if it\n  // sees `{{` followed by a malformed tag.\n  var rest, type;\n  return (scanner.peek() === '{' &&\n          (rest = scanner.rest()).slice(0, 2) === '{{' &&\n          /^\\{\\{\\s*(\\/|else\\b)/.test(rest) &&\n          (type = TemplateTag.peek(scanner).type) &&\n          (type === 'BLOCKCLOSE' || type === 'ELSE'));\n};\n\n// Validate that `templateTag` is correctly formed and legal for its\n// HTML position.  Use `scanner` to report errors. On success, does\n// nothing.\nvar validateTag = function (ttag, scanner) {\n\n  if (ttag.type === 'INCLUSION' || ttag.type === 'BLOCKOPEN') {\n    var args = ttag.args;\n    if (ttag.path[0] === 'each' && args[1] && args[1][0] === 'PATH' &&\n        args[1][1][0] === 'in') {\n      // For slightly better error messages, we detect the each-in case\n      // here in order not to complain if the user writes `{{#each 3 in x}}`\n      // that \"3 is not a function\"\n    } else {\n      if (args.length > 1 && args[0].length === 2 && args[0][0] !== 'PATH') {\n        // we have a positional argument that is not a PATH followed by\n        // other arguments\n        scanner.fatal(\"First argument must be a function, to be called on \" +\n                      \"the rest of the arguments; found \" + args[0][0]);\n      }\n    }\n  }\n\n  var position = ttag.position || TEMPLATE_TAG_POSITION.ELEMENT;\n  if (position === TEMPLATE_TAG_POSITION.IN_ATTRIBUTE) {\n    if (ttag.type === 'DOUBLE' || ttag.type === 'ESCAPE') {\n      return;\n    } else if (ttag.type === 'BLOCKOPEN') {\n      var path = ttag.path;\n      var path0 = path[0];\n      if (! (path.length === 1 && (path0 === 'if' ||\n                                   path0 === 'unless' ||\n                                   path0 === 'with' ||\n                                   path0 === 'each'))) {\n        scanner.fatal(\"Custom block helpers are not allowed in an HTML attribute, only built-in ones like #each and #if\");\n      }\n    } else {\n      scanner.fatal(ttag.type + \" template tag is not allowed in an HTML attribute\");\n    }\n  } else if (position === TEMPLATE_TAG_POSITION.IN_START_TAG) {\n    if (! (ttag.type === 'DOUBLE')) {\n      scanner.fatal(\"Reactive HTML attributes must either have a constant name or consist of a single {{helper}} providing a dictionary of names and values.  A template tag of type \" + ttag.type + \" is not allowed here.\");\n    }\n    if (scanner.peek() === '=') {\n      scanner.fatal(\"Template tags are not allowed in attribute names, only in attribute values or in the form of a single {{helper}} that evaluates to a dictionary of name=value pairs.\");\n    }\n  }\n\n};\n"]},"sourceType":"module","hash":"05fdd73f48895468ce7c294b9a1db2b822a9fe21"}
