{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"C:\\Users\\RUBEN\\Desktop\\meteor-vue\\packages\\spacebars-compiler\\codegen.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.windows.x86_64"},"sourceFileName":"packages/spacebars-compiler/codegen.js","filename":"C:\\Users\\RUBEN\\Desktop\\meteor-vue\\packages\\spacebars-compiler\\codegen.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"C:\\Users\\RUBEN\\Desktop\\meteor-vue","root":"C:\\Users\\RUBEN\\Desktop\\meteor-vue","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true}},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.14.0","helpers":true,"useESModules":false,"corejs":false}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":true,"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_verified":true},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}}],"presets":[],"generatorOpts":{"filename":"C:\\Users\\RUBEN\\Desktop\\meteor-vue\\packages\\spacebars-compiler\\codegen.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/spacebars-compiler/codegen.js"}},"code":"module.export({\n  CodeGen: () => CodeGen,\n  builtInBlockHelpers: () => builtInBlockHelpers,\n  isReservedName: () => isReservedName\n});\nlet HTMLTools;\nmodule.link(\"meteor/html-tools\", {\n  HTMLTools(v) {\n    HTMLTools = v;\n  }\n\n}, 0);\nlet HTML;\nmodule.link(\"meteor/htmljs\", {\n  HTML(v) {\n    HTML = v;\n  }\n\n}, 1);\nlet BlazeTools;\nmodule.link(\"meteor/blaze-tools\", {\n  BlazeTools(v) {\n    BlazeTools = v;\n  }\n\n}, 2);\nlet codeGen;\nmodule.link(\"./compiler\", {\n  codeGen(v) {\n    codeGen = v;\n  }\n\n}, 3);\n\nfunction CodeGen() {}\n\nconst builtInBlockHelpers = {\n  'if': 'Blaze.If',\n  'unless': 'Blaze.Unless',\n  'with': 'Spacebars.With',\n  'each': 'Blaze.Each',\n  'let': 'Blaze.Let'\n};\n// Mapping of \"macros\" which, when preceded by `Template.`, expand\n// to special code rather than following the lookup rules for dotted\n// symbols.\nvar builtInTemplateMacros = {\n  // `view` is a local variable defined in the generated render\n  // function for the template in which `Template.contentBlock` or\n  // `Template.elseBlock` is invoked.\n  'contentBlock': 'view.templateContentBlock',\n  'elseBlock': 'view.templateElseBlock',\n  // Confusingly, this makes `{{> Template.dynamic}}` an alias\n  // for `{{> __dynamic}}`, where \"__dynamic\" is the template that\n  // implements the dynamic template feature.\n  'dynamic': 'Template.__dynamic',\n  'subscriptionsReady': 'view.templateInstance().subscriptionsReady()'\n};\nvar additionalReservedNames = [\"body\", \"toString\", \"instance\", \"constructor\", \"toString\", \"toLocaleString\", \"valueOf\", \"hasOwnProperty\", \"isPrototypeOf\", \"propertyIsEnumerable\", \"__defineGetter__\", \"__lookupGetter__\", \"__defineSetter__\", \"__lookupSetter__\", \"__proto__\", \"dynamic\", \"registerHelper\", \"currentData\", \"parentData\", \"_migrateTemplate\", \"_applyHmrChanges\", \"__pendingReplacement\"]; // A \"reserved name\" can't be used as a <template> name.  This\n// function is used by the template file scanner.\n//\n// Note that the runtime imposes additional restrictions, for example\n// banning the name \"body\" and names of built-in object properties\n// like \"toString\".\n\nfunction isReservedName(name) {\n  return builtInBlockHelpers.hasOwnProperty(name) || builtInTemplateMacros.hasOwnProperty(name) || _.indexOf(additionalReservedNames, name) > -1;\n}\n\nvar makeObjectLiteral = function (obj) {\n  var parts = [];\n\n  for (var k in obj) parts.push(BlazeTools.toObjectLiteralKey(k) + ': ' + obj[k]);\n\n  return '{' + parts.join(', ') + '}';\n};\n\n_.extend(CodeGen.prototype, {\n  codeGenTemplateTag: function (tag) {\n    var self = this;\n\n    if (tag.position === HTMLTools.TEMPLATE_TAG_POSITION.IN_START_TAG) {\n      // Special dynamic attributes: `<div {{attrs}}>...`\n      // only `tag.type === 'DOUBLE'` allowed (by earlier validation)\n      return BlazeTools.EmitCode('function () { return ' + self.codeGenMustache(tag.path, tag.args, 'attrMustache') + '; }');\n    } else {\n      if (tag.type === 'DOUBLE' || tag.type === 'TRIPLE') {\n        var code = self.codeGenMustache(tag.path, tag.args);\n\n        if (tag.type === 'TRIPLE') {\n          code = 'Spacebars.makeRaw(' + code + ')';\n        }\n\n        if (tag.position !== HTMLTools.TEMPLATE_TAG_POSITION.IN_ATTRIBUTE) {\n          // Reactive attributes are already wrapped in a function,\n          // and there's no fine-grained reactivity.\n          // Anywhere else, we need to create a View.\n          code = 'Blaze.View(' + BlazeTools.toJSLiteral('lookup:' + tag.path.join('.')) + ', ' + 'function () { return ' + code + '; })';\n        }\n\n        return BlazeTools.EmitCode(code);\n      } else if (tag.type === 'INCLUSION' || tag.type === 'BLOCKOPEN') {\n        var path = tag.path;\n        var args = tag.args;\n\n        if (tag.type === 'BLOCKOPEN' && builtInBlockHelpers.hasOwnProperty(path[0])) {\n          // if, unless, with, each.\n          //\n          // If someone tries to do `{{> if}}`, we don't\n          // get here, but an error is thrown when we try to codegen the path.\n          // Note: If we caught these errors earlier, while scanning, we'd be able to\n          // provide nice line numbers.\n          if (path.length > 1) throw new Error(\"Unexpected dotted path beginning with \" + path[0]);\n          if (!args.length) throw new Error(\"#\" + path[0] + \" requires an argument\");\n          var dataCode = null; // #each has a special treatment as it features two different forms:\n          // - {{#each people}}\n          // - {{#each person in people}}\n\n          if (path[0] === 'each' && args.length >= 2 && args[1][0] === 'PATH' && args[1][1].length && args[1][1][0] === 'in') {\n            // minimum conditions are met for each-in.  now validate this\n            // isn't some weird case.\n            var eachUsage = \"Use either {{#each items}} or \" + \"{{#each item in items}} form of #each.\";\n            var inArg = args[1];\n\n            if (!(args.length >= 3 && inArg[1].length === 1)) {\n              // we don't have at least 3 space-separated parts after #each, or\n              // inArg doesn't look like ['PATH',['in']]\n              throw new Error(\"Malformed #each. \" + eachUsage);\n            } // split out the variable name and sequence arguments\n\n\n            var variableArg = args[0];\n\n            if (!(variableArg[0] === \"PATH\" && variableArg[1].length === 1 && variableArg[1][0].replace(/\\./g, ''))) {\n              throw new Error(\"Bad variable name in #each\");\n            }\n\n            var variable = variableArg[1][0];\n            dataCode = 'function () { return { _sequence: ' + self.codeGenInclusionData(args.slice(2)) + ', _variable: ' + BlazeTools.toJSLiteral(variable) + ' }; }';\n          } else if (path[0] === 'let') {\n            var dataProps = {};\n\n            _.each(args, function (arg) {\n              if (arg.length !== 3) {\n                // not a keyword arg (x=y)\n                throw new Error(\"Incorrect form of #let\");\n              }\n\n              var argKey = arg[2];\n              dataProps[argKey] = 'function () { return Spacebars.call(' + self.codeGenArgValue(arg) + '); }';\n            });\n\n            dataCode = makeObjectLiteral(dataProps);\n          }\n\n          if (!dataCode) {\n            // `args` must exist (tag.args.length > 0)\n            dataCode = self.codeGenInclusionDataFunc(args) || 'null';\n          } // `content` must exist\n\n\n          var contentBlock = 'content' in tag ? self.codeGenBlock(tag.content) : null; // `elseContent` may not exist\n\n          var elseContentBlock = 'elseContent' in tag ? self.codeGenBlock(tag.elseContent) : null;\n          var callArgs = [dataCode, contentBlock];\n          if (elseContentBlock) callArgs.push(elseContentBlock);\n          return BlazeTools.EmitCode(builtInBlockHelpers[path[0]] + '(' + callArgs.join(', ') + ')');\n        } else {\n          var compCode = self.codeGenPath(path, {\n            lookupTemplate: true\n          });\n\n          if (path.length > 1) {\n            // capture reactivity\n            compCode = 'function () { return Spacebars.call(' + compCode + '); }';\n          }\n\n          var dataCode = self.codeGenInclusionDataFunc(tag.args);\n          var content = 'content' in tag ? self.codeGenBlock(tag.content) : null;\n          var elseContent = 'elseContent' in tag ? self.codeGenBlock(tag.elseContent) : null;\n          var includeArgs = [compCode];\n\n          if (content) {\n            includeArgs.push(content);\n            if (elseContent) includeArgs.push(elseContent);\n          }\n\n          var includeCode = 'Spacebars.include(' + includeArgs.join(', ') + ')'; // calling convention compat -- set the data context around the\n          // entire inclusion, so that if the name of the inclusion is\n          // a helper function, it gets the data context in `this`.\n          // This makes for a pretty confusing calling convention --\n          // In `{{#foo bar}}`, `foo` is evaluated in the context of `bar`\n          // -- but it's what we shipped for 0.8.0.  The rationale is that\n          // `{{#foo bar}}` is sugar for `{{#with bar}}{{#foo}}...`.\n\n          if (dataCode) {\n            includeCode = 'Blaze._TemplateWith(' + dataCode + ', function () { return ' + includeCode + '; })';\n          } // XXX BACK COMPAT - UI is the old name, Template is the new\n\n\n          if ((path[0] === 'UI' || path[0] === 'Template') && (path[1] === 'contentBlock' || path[1] === 'elseBlock')) {\n            // Call contentBlock and elseBlock in the appropriate scope\n            includeCode = 'Blaze._InOuterTemplateScope(view, function () { return ' + includeCode + '; })';\n          }\n\n          return BlazeTools.EmitCode(includeCode);\n        }\n      } else if (tag.type === 'ESCAPE') {\n        return tag.value;\n      } else {\n        // Can't get here; TemplateTag validation should catch any\n        // inappropriate tag types that might come out of the parser.\n        throw new Error(\"Unexpected template tag type: \" + tag.type);\n      }\n    }\n  },\n  // `path` is an array of at least one string.\n  //\n  // If `path.length > 1`, the generated code may be reactive\n  // (i.e. it may invalidate the current computation).\n  //\n  // No code is generated to call the result if it's a function.\n  //\n  // Options:\n  //\n  // - lookupTemplate {Boolean} If true, generated code also looks in\n  //   the list of templates. (After helpers, before data context).\n  //   Used when generating code for `{{> foo}}` or `{{#foo}}`. Only\n  //   used for non-dotted paths.\n  codeGenPath: function (path, opts) {\n    if (builtInBlockHelpers.hasOwnProperty(path[0])) throw new Error(\"Can't use the built-in '\" + path[0] + \"' here\"); // Let `{{#if Template.contentBlock}}` check whether this template was\n    // invoked via inclusion or as a block helper, in addition to supporting\n    // `{{> Template.contentBlock}}`.\n    // XXX BACK COMPAT - UI is the old name, Template is the new\n\n    if (path.length >= 2 && (path[0] === 'UI' || path[0] === 'Template') && builtInTemplateMacros.hasOwnProperty(path[1])) {\n      if (path.length > 2) throw new Error(\"Unexpected dotted path beginning with \" + path[0] + '.' + path[1]);\n      return builtInTemplateMacros[path[1]];\n    }\n\n    var firstPathItem = BlazeTools.toJSLiteral(path[0]);\n    var lookupMethod = 'lookup';\n    if (opts && opts.lookupTemplate && path.length === 1) lookupMethod = 'lookupTemplate';\n    var code = 'view.' + lookupMethod + '(' + firstPathItem + ')';\n\n    if (path.length > 1) {\n      code = 'Spacebars.dot(' + code + ', ' + _.map(path.slice(1), BlazeTools.toJSLiteral).join(', ') + ')';\n    }\n\n    return code;\n  },\n  // Generates code for an `[argType, argValue]` argument spec,\n  // ignoring the third element (keyword argument name) if present.\n  //\n  // The resulting code may be reactive (in the case of a PATH of\n  // more than one element) and is not wrapped in a closure.\n  codeGenArgValue: function (arg) {\n    var self = this;\n    var argType = arg[0];\n    var argValue = arg[1];\n    var argCode;\n\n    switch (argType) {\n      case 'STRING':\n      case 'NUMBER':\n      case 'BOOLEAN':\n      case 'NULL':\n        argCode = BlazeTools.toJSLiteral(argValue);\n        break;\n\n      case 'PATH':\n        argCode = self.codeGenPath(argValue);\n        break;\n\n      case 'EXPR':\n        // The format of EXPR is ['EXPR', { type: 'EXPR', path: [...], args: { ... } }]\n        argCode = self.codeGenMustache(argValue.path, argValue.args, 'dataMustache');\n        break;\n\n      default:\n        // can't get here\n        throw new Error(\"Unexpected arg type: \" + argType);\n    }\n\n    return argCode;\n  },\n  // Generates a call to `Spacebars.fooMustache` on evaluated arguments.\n  // The resulting code has no function literals and must be wrapped in\n  // one for fine-grained reactivity.\n  codeGenMustache: function (path, args, mustacheType) {\n    var self = this;\n    var nameCode = self.codeGenPath(path);\n    var argCode = self.codeGenMustacheArgs(args);\n    var mustache = mustacheType || 'mustache';\n    return 'Spacebars.' + mustache + '(' + nameCode + (argCode ? ', ' + argCode.join(', ') : '') + ')';\n  },\n  // returns: array of source strings, or null if no\n  // args at all.\n  codeGenMustacheArgs: function (tagArgs) {\n    var self = this;\n    var kwArgs = null; // source -> source\n\n    var args = null; // [source]\n    // tagArgs may be null\n\n    _.each(tagArgs, function (arg) {\n      var argCode = self.codeGenArgValue(arg);\n\n      if (arg.length > 2) {\n        // keyword argument (represented as [type, value, name])\n        kwArgs = kwArgs || {};\n        kwArgs[arg[2]] = argCode;\n      } else {\n        // positional argument\n        args = args || [];\n        args.push(argCode);\n      }\n    }); // put kwArgs in options dictionary at end of args\n\n\n    if (kwArgs) {\n      args = args || [];\n      args.push('Spacebars.kw(' + makeObjectLiteral(kwArgs) + ')');\n    }\n\n    return args;\n  },\n  codeGenBlock: function (content) {\n    return codeGen(content);\n  },\n  codeGenInclusionData: function (args) {\n    var self = this;\n\n    if (!args.length) {\n      // e.g. `{{#foo}}`\n      return null;\n    } else if (args[0].length === 3) {\n      // keyword arguments only, e.g. `{{> point x=1 y=2}}`\n      var dataProps = {};\n\n      _.each(args, function (arg) {\n        var argKey = arg[2];\n        dataProps[argKey] = 'Spacebars.call(' + self.codeGenArgValue(arg) + ')';\n      });\n\n      return makeObjectLiteral(dataProps);\n    } else if (args[0][0] !== 'PATH') {\n      // literal first argument, e.g. `{{> foo \"blah\"}}`\n      //\n      // tag validation has confirmed, in this case, that there is only\n      // one argument (`args.length === 1`)\n      return self.codeGenArgValue(args[0]);\n    } else if (args.length === 1) {\n      // one argument, must be a PATH\n      return 'Spacebars.call(' + self.codeGenPath(args[0][1]) + ')';\n    } else {\n      // Multiple positional arguments; treat them as a nested\n      // \"data mustache\"\n      return self.codeGenMustache(args[0][1], args.slice(1), 'dataMustache');\n    }\n  },\n  codeGenInclusionDataFunc: function (args) {\n    var self = this;\n    var dataCode = self.codeGenInclusionData(args);\n\n    if (dataCode) {\n      return 'function () { return ' + dataCode + '; }';\n    } else {\n      return null;\n    }\n  }\n});","map":{"version":3,"sources":["packages/spacebars-compiler/codegen.js"],"names":["module","export","CodeGen","builtInBlockHelpers","isReservedName","HTMLTools","link","v","HTML","BlazeTools","codeGen","builtInTemplateMacros","additionalReservedNames","name","hasOwnProperty","_","indexOf","makeObjectLiteral","obj","parts","k","push","toObjectLiteralKey","join","extend","prototype","codeGenTemplateTag","tag","self","position","TEMPLATE_TAG_POSITION","IN_START_TAG","EmitCode","codeGenMustache","path","args","type","code","IN_ATTRIBUTE","toJSLiteral","length","Error","dataCode","eachUsage","inArg","variableArg","replace","variable","codeGenInclusionData","slice","dataProps","each","arg","argKey","codeGenArgValue","codeGenInclusionDataFunc","contentBlock","codeGenBlock","content","elseContentBlock","elseContent","callArgs","compCode","codeGenPath","lookupTemplate","includeArgs","includeCode","value","opts","firstPathItem","lookupMethod","map","argType","argValue","argCode","mustacheType","nameCode","codeGenMustacheArgs","mustache","tagArgs","kwArgs"],"mappings":"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","sourcesContent":["import { HTMLTools } from 'meteor/html-tools';\nimport { HTML } from 'meteor/htmljs';\nimport { BlazeTools } from 'meteor/blaze-tools';\nimport { codeGen } from './compiler';\n\n\n// ============================================================\n// Code-generation of template tags\n\n// The `CodeGen` class currently has no instance state, but in theory\n// it could be useful to track per-function state, like whether we\n// need to emit `var self = this` or not.\nexport function CodeGen() {}\n\nexport const builtInBlockHelpers = {\n  'if': 'Blaze.If',\n  'unless': 'Blaze.Unless',\n  'with': 'Spacebars.With',\n  'each': 'Blaze.Each',\n  'let': 'Blaze.Let'\n};\n\n\n// Mapping of \"macros\" which, when preceded by `Template.`, expand\n// to special code rather than following the lookup rules for dotted\n// symbols.\nvar builtInTemplateMacros = {\n  // `view` is a local variable defined in the generated render\n  // function for the template in which `Template.contentBlock` or\n  // `Template.elseBlock` is invoked.\n  'contentBlock': 'view.templateContentBlock',\n  'elseBlock': 'view.templateElseBlock',\n\n  // Confusingly, this makes `{{> Template.dynamic}}` an alias\n  // for `{{> __dynamic}}`, where \"__dynamic\" is the template that\n  // implements the dynamic template feature.\n  'dynamic': 'Template.__dynamic',\n\n  'subscriptionsReady': 'view.templateInstance().subscriptionsReady()'\n};\n\nvar additionalReservedNames = [\"body\", \"toString\", \"instance\",  \"constructor\",\n  \"toString\", \"toLocaleString\", \"valueOf\", \"hasOwnProperty\", \"isPrototypeOf\",\n  \"propertyIsEnumerable\", \"__defineGetter__\", \"__lookupGetter__\",\n  \"__defineSetter__\", \"__lookupSetter__\", \"__proto__\", \"dynamic\",\n  \"registerHelper\", \"currentData\", \"parentData\", \"_migrateTemplate\",\n  \"_applyHmrChanges\", \"__pendingReplacement\"\n];\n\n// A \"reserved name\" can't be used as a <template> name.  This\n// function is used by the template file scanner.\n//\n// Note that the runtime imposes additional restrictions, for example\n// banning the name \"body\" and names of built-in object properties\n// like \"toString\".\nexport function isReservedName(name) {\n  return builtInBlockHelpers.hasOwnProperty(name) ||\n    builtInTemplateMacros.hasOwnProperty(name) ||\n    _.indexOf(additionalReservedNames, name) > -1;\n}\n\nvar makeObjectLiteral = function (obj) {\n  var parts = [];\n  for (var k in obj)\n    parts.push(BlazeTools.toObjectLiteralKey(k) + ': ' + obj[k]);\n  return '{' + parts.join(', ') + '}';\n};\n\n_.extend(CodeGen.prototype, {\n  codeGenTemplateTag: function (tag) {\n    var self = this;\n    if (tag.position === HTMLTools.TEMPLATE_TAG_POSITION.IN_START_TAG) {\n      // Special dynamic attributes: `<div {{attrs}}>...`\n      // only `tag.type === 'DOUBLE'` allowed (by earlier validation)\n      return BlazeTools.EmitCode('function () { return ' +\n          self.codeGenMustache(tag.path, tag.args, 'attrMustache')\n          + '; }');\n    } else {\n      if (tag.type === 'DOUBLE' || tag.type === 'TRIPLE') {\n        var code = self.codeGenMustache(tag.path, tag.args);\n        if (tag.type === 'TRIPLE') {\n          code = 'Spacebars.makeRaw(' + code + ')';\n        }\n        if (tag.position !== HTMLTools.TEMPLATE_TAG_POSITION.IN_ATTRIBUTE) {\n          // Reactive attributes are already wrapped in a function,\n          // and there's no fine-grained reactivity.\n          // Anywhere else, we need to create a View.\n          code = 'Blaze.View(' +\n            BlazeTools.toJSLiteral('lookup:' + tag.path.join('.')) + ', ' +\n            'function () { return ' + code + '; })';\n        }\n        return BlazeTools.EmitCode(code);\n      } else if (tag.type === 'INCLUSION' || tag.type === 'BLOCKOPEN') {\n        var path = tag.path;\n        var args = tag.args;\n\n        if (tag.type === 'BLOCKOPEN' &&\n            builtInBlockHelpers.hasOwnProperty(path[0])) {\n          // if, unless, with, each.\n          //\n          // If someone tries to do `{{> if}}`, we don't\n          // get here, but an error is thrown when we try to codegen the path.\n\n          // Note: If we caught these errors earlier, while scanning, we'd be able to\n          // provide nice line numbers.\n          if (path.length > 1)\n            throw new Error(\"Unexpected dotted path beginning with \" + path[0]);\n          if (! args.length)\n            throw new Error(\"#\" + path[0] + \" requires an argument\");\n\n          var dataCode = null;\n          // #each has a special treatment as it features two different forms:\n          // - {{#each people}}\n          // - {{#each person in people}}\n          if (path[0] === 'each' && args.length >= 2 && args[1][0] === 'PATH' &&\n              args[1][1].length && args[1][1][0] === 'in') {\n            // minimum conditions are met for each-in.  now validate this\n            // isn't some weird case.\n            var eachUsage = \"Use either {{#each items}} or \" +\n                  \"{{#each item in items}} form of #each.\";\n            var inArg = args[1];\n            if (! (args.length >= 3 && inArg[1].length === 1)) {\n              // we don't have at least 3 space-separated parts after #each, or\n              // inArg doesn't look like ['PATH',['in']]\n              throw new Error(\"Malformed #each. \" + eachUsage);\n            }\n            // split out the variable name and sequence arguments\n            var variableArg = args[0];\n            if (! (variableArg[0] === \"PATH\" && variableArg[1].length === 1 &&\n                   variableArg[1][0].replace(/\\./g, ''))) {\n              throw new Error(\"Bad variable name in #each\");\n            }\n            var variable = variableArg[1][0];\n            dataCode = 'function () { return { _sequence: ' +\n              self.codeGenInclusionData(args.slice(2)) +\n              ', _variable: ' + BlazeTools.toJSLiteral(variable) + ' }; }';\n          } else if (path[0] === 'let') {\n            var dataProps = {};\n            _.each(args, function (arg) {\n              if (arg.length !== 3) {\n                // not a keyword arg (x=y)\n                throw new Error(\"Incorrect form of #let\");\n              }\n              var argKey = arg[2];\n              dataProps[argKey] =\n                'function () { return Spacebars.call(' +\n                self.codeGenArgValue(arg) + '); }';\n            });\n            dataCode = makeObjectLiteral(dataProps);\n          }\n\n          if (! dataCode) {\n            // `args` must exist (tag.args.length > 0)\n            dataCode = self.codeGenInclusionDataFunc(args) || 'null';\n          }\n\n          // `content` must exist\n          var contentBlock = (('content' in tag) ?\n                              self.codeGenBlock(tag.content) : null);\n          // `elseContent` may not exist\n          var elseContentBlock = (('elseContent' in tag) ?\n                                  self.codeGenBlock(tag.elseContent) : null);\n\n          var callArgs = [dataCode, contentBlock];\n          if (elseContentBlock)\n            callArgs.push(elseContentBlock);\n\n          return BlazeTools.EmitCode(\n            builtInBlockHelpers[path[0]] + '(' + callArgs.join(', ') + ')');\n\n        } else {\n          var compCode = self.codeGenPath(path, {lookupTemplate: true});\n          if (path.length > 1) {\n            // capture reactivity\n            compCode = 'function () { return Spacebars.call(' + compCode +\n              '); }';\n          }\n\n          var dataCode = self.codeGenInclusionDataFunc(tag.args);\n          var content = (('content' in tag) ?\n                         self.codeGenBlock(tag.content) : null);\n          var elseContent = (('elseContent' in tag) ?\n                             self.codeGenBlock(tag.elseContent) : null);\n\n          var includeArgs = [compCode];\n          if (content) {\n            includeArgs.push(content);\n            if (elseContent)\n              includeArgs.push(elseContent);\n          }\n\n          var includeCode =\n                'Spacebars.include(' + includeArgs.join(', ') + ')';\n\n          // calling convention compat -- set the data context around the\n          // entire inclusion, so that if the name of the inclusion is\n          // a helper function, it gets the data context in `this`.\n          // This makes for a pretty confusing calling convention --\n          // In `{{#foo bar}}`, `foo` is evaluated in the context of `bar`\n          // -- but it's what we shipped for 0.8.0.  The rationale is that\n          // `{{#foo bar}}` is sugar for `{{#with bar}}{{#foo}}...`.\n          if (dataCode) {\n            includeCode =\n              'Blaze._TemplateWith(' + dataCode + ', function () { return ' +\n              includeCode + '; })';\n          }\n\n          // XXX BACK COMPAT - UI is the old name, Template is the new\n          if ((path[0] === 'UI' || path[0] === 'Template') &&\n              (path[1] === 'contentBlock' || path[1] === 'elseBlock')) {\n            // Call contentBlock and elseBlock in the appropriate scope\n            includeCode = 'Blaze._InOuterTemplateScope(view, function () { return '\n              + includeCode + '; })';\n          }\n\n          return BlazeTools.EmitCode(includeCode);\n        }\n      } else if (tag.type === 'ESCAPE') {\n        return tag.value;\n      } else {\n        // Can't get here; TemplateTag validation should catch any\n        // inappropriate tag types that might come out of the parser.\n        throw new Error(\"Unexpected template tag type: \" + tag.type);\n      }\n    }\n  },\n\n  // `path` is an array of at least one string.\n  //\n  // If `path.length > 1`, the generated code may be reactive\n  // (i.e. it may invalidate the current computation).\n  //\n  // No code is generated to call the result if it's a function.\n  //\n  // Options:\n  //\n  // - lookupTemplate {Boolean} If true, generated code also looks in\n  //   the list of templates. (After helpers, before data context).\n  //   Used when generating code for `{{> foo}}` or `{{#foo}}`. Only\n  //   used for non-dotted paths.\n  codeGenPath: function (path, opts) {\n    if (builtInBlockHelpers.hasOwnProperty(path[0]))\n      throw new Error(\"Can't use the built-in '\" + path[0] + \"' here\");\n    // Let `{{#if Template.contentBlock}}` check whether this template was\n    // invoked via inclusion or as a block helper, in addition to supporting\n    // `{{> Template.contentBlock}}`.\n    // XXX BACK COMPAT - UI is the old name, Template is the new\n    if (path.length >= 2 &&\n        (path[0] === 'UI' || path[0] === 'Template')\n        && builtInTemplateMacros.hasOwnProperty(path[1])) {\n      if (path.length > 2)\n        throw new Error(\"Unexpected dotted path beginning with \" +\n                        path[0] + '.' + path[1]);\n      return builtInTemplateMacros[path[1]];\n    }\n\n    var firstPathItem = BlazeTools.toJSLiteral(path[0]);\n    var lookupMethod = 'lookup';\n    if (opts && opts.lookupTemplate && path.length === 1)\n      lookupMethod = 'lookupTemplate';\n    var code = 'view.' + lookupMethod + '(' + firstPathItem + ')';\n\n    if (path.length > 1) {\n      code = 'Spacebars.dot(' + code + ', ' +\n        _.map(path.slice(1), BlazeTools.toJSLiteral).join(', ') + ')';\n    }\n\n    return code;\n  },\n\n  // Generates code for an `[argType, argValue]` argument spec,\n  // ignoring the third element (keyword argument name) if present.\n  //\n  // The resulting code may be reactive (in the case of a PATH of\n  // more than one element) and is not wrapped in a closure.\n  codeGenArgValue: function (arg) {\n    var self = this;\n\n    var argType = arg[0];\n    var argValue = arg[1];\n\n    var argCode;\n    switch (argType) {\n    case 'STRING':\n    case 'NUMBER':\n    case 'BOOLEAN':\n    case 'NULL':\n      argCode = BlazeTools.toJSLiteral(argValue);\n      break;\n    case 'PATH':\n      argCode = self.codeGenPath(argValue);\n      break;\n    case 'EXPR':\n      // The format of EXPR is ['EXPR', { type: 'EXPR', path: [...], args: { ... } }]\n      argCode = self.codeGenMustache(argValue.path, argValue.args, 'dataMustache');\n      break;\n    default:\n      // can't get here\n      throw new Error(\"Unexpected arg type: \" + argType);\n    }\n\n    return argCode;\n  },\n\n  // Generates a call to `Spacebars.fooMustache` on evaluated arguments.\n  // The resulting code has no function literals and must be wrapped in\n  // one for fine-grained reactivity.\n  codeGenMustache: function (path, args, mustacheType) {\n    var self = this;\n\n    var nameCode = self.codeGenPath(path);\n    var argCode = self.codeGenMustacheArgs(args);\n    var mustache = (mustacheType || 'mustache');\n\n    return 'Spacebars.' + mustache + '(' + nameCode +\n      (argCode ? ', ' + argCode.join(', ') : '') + ')';\n  },\n\n  // returns: array of source strings, or null if no\n  // args at all.\n  codeGenMustacheArgs: function (tagArgs) {\n    var self = this;\n\n    var kwArgs = null; // source -> source\n    var args = null; // [source]\n\n    // tagArgs may be null\n    _.each(tagArgs, function (arg) {\n      var argCode = self.codeGenArgValue(arg);\n\n      if (arg.length > 2) {\n        // keyword argument (represented as [type, value, name])\n        kwArgs = (kwArgs || {});\n        kwArgs[arg[2]] = argCode;\n      } else {\n        // positional argument\n        args = (args || []);\n        args.push(argCode);\n      }\n    });\n\n    // put kwArgs in options dictionary at end of args\n    if (kwArgs) {\n      args = (args || []);\n      args.push('Spacebars.kw(' + makeObjectLiteral(kwArgs) + ')');\n    }\n\n    return args;\n  },\n\n  codeGenBlock: function (content) {\n    return codeGen(content);\n  },\n\n  codeGenInclusionData: function (args) {\n    var self = this;\n\n    if (! args.length) {\n      // e.g. `{{#foo}}`\n      return null;\n    } else if (args[0].length === 3) {\n      // keyword arguments only, e.g. `{{> point x=1 y=2}}`\n      var dataProps = {};\n      _.each(args, function (arg) {\n        var argKey = arg[2];\n        dataProps[argKey] = 'Spacebars.call(' + self.codeGenArgValue(arg) + ')';\n      });\n      return makeObjectLiteral(dataProps);\n    } else if (args[0][0] !== 'PATH') {\n      // literal first argument, e.g. `{{> foo \"blah\"}}`\n      //\n      // tag validation has confirmed, in this case, that there is only\n      // one argument (`args.length === 1`)\n      return self.codeGenArgValue(args[0]);\n    } else if (args.length === 1) {\n      // one argument, must be a PATH\n      return 'Spacebars.call(' + self.codeGenPath(args[0][1]) + ')';\n    } else {\n      // Multiple positional arguments; treat them as a nested\n      // \"data mustache\"\n      return self.codeGenMustache(args[0][1], args.slice(1),\n                                  'dataMustache');\n    }\n\n  },\n\n  codeGenInclusionDataFunc: function (args) {\n    var self = this;\n    var dataCode = self.codeGenInclusionData(args);\n    if (dataCode) {\n      return 'function () { return ' + dataCode + '; }';\n    } else {\n      return null;\n    }\n  }\n\n});\n"]},"sourceType":"module","hash":"01e3ad79e5488b5cf5cfaaa3f8256111eb5d3345"}
