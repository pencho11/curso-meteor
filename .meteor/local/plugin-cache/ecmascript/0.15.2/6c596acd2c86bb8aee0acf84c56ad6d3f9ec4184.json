{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"C:\\Users\\RUBEN\\Desktop\\meteor-vue\\packages\\html-tools\\parse.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.windows.x86_64"},"sourceFileName":"packages/html-tools/parse.js","filename":"C:\\Users\\RUBEN\\Desktop\\meteor-vue\\packages\\html-tools\\parse.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"C:\\Users\\RUBEN\\Desktop\\meteor-vue","root":"C:\\Users\\RUBEN\\Desktop\\meteor-vue","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true}},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.14.0","helpers":true,"useESModules":false,"corejs":false}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":true,"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_verified":true},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}}],"presets":[],"generatorOpts":{"filename":"C:\\Users\\RUBEN\\Desktop\\meteor-vue\\packages\\html-tools\\parse.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/html-tools/parse.js"}},"code":"module.export({\n  parseFragment: () => parseFragment,\n  codePointToString: () => codePointToString,\n  getContent: () => getContent,\n  getRCData: () => getRCData\n});\nlet HTML;\nmodule.link(\"meteor/htmljs\", {\n  HTML(v) {\n    HTML = v;\n  }\n\n}, 0);\nlet Scanner;\nmodule.link(\"./scanner\", {\n  Scanner(v) {\n    Scanner = v;\n  }\n\n}, 1);\nlet properCaseAttributeName;\nmodule.link(\"./utils\", {\n  properCaseAttributeName(v) {\n    properCaseAttributeName = v;\n  }\n\n}, 2);\nlet getHTMLToken, isLookingAtEndTag;\nmodule.link(\"./tokenize\", {\n  getHTMLToken(v) {\n    getHTMLToken = v;\n  },\n\n  isLookingAtEndTag(v) {\n    isLookingAtEndTag = v;\n  }\n\n}, 3);\n\nfunction parseFragment(input, options) {\n  var scanner;\n  if (typeof input === 'string') scanner = new Scanner(input);else // input can be a scanner.  We'd better not have a different\n    // value for the \"getTemplateTag\" option as when the scanner\n    // was created, because we don't do anything special to reset\n    // the value (which is attached to the scanner).\n    scanner = input; // ```\n  // { getTemplateTag: function (scanner, templateTagPosition) {\n  //     if (templateTagPosition === HTMLTools.TEMPLATE_TAG_POSITION.ELEMENT) {\n  //       ...\n  // ```\n\n  if (options && options.getTemplateTag) scanner.getTemplateTag = options.getTemplateTag; // function (scanner) -> boolean\n\n  var shouldStop = options && options.shouldStop;\n  var result;\n\n  if (options && options.textMode) {\n    if (options.textMode === HTML.TEXTMODE.STRING) {\n      result = getRawText(scanner, null, shouldStop);\n    } else if (options.textMode === HTML.TEXTMODE.RCDATA) {\n      result = getRCData(scanner, null, shouldStop);\n    } else {\n      throw new Error(\"Unsupported textMode: \" + options.textMode);\n    }\n  } else {\n    result = getContent(scanner, shouldStop);\n  }\n\n  if (!scanner.isEOF()) {\n    // If we aren't at the end of the input, we either stopped at an unmatched\n    // HTML end tag or at a template tag (like `{{else}}` or `{{/if}}`).\n    // Detect the former case (stopped at an HTML end tag) and throw a good\n    // error.\n    var posBefore = scanner.pos;\n\n    try {\n      var endTag = getHTMLToken(scanner);\n    } catch (e) {// ignore errors from getTemplateTag\n    } // XXX we make some assumptions about shouldStop here, like that it\n    // won't tell us to stop at an HTML end tag.  Should refactor\n    // `shouldStop` into something more suitable.\n\n\n    if (endTag && endTag.t === 'Tag' && endTag.isEnd) {\n      var closeTag = endTag.n;\n      var isVoidElement = HTML.isVoidElement(closeTag);\n      scanner.fatal(\"Unexpected HTML close tag\" + (isVoidElement ? '.  <' + endTag.n + '> should have no close tag.' : ''));\n    }\n\n    scanner.pos = posBefore; // rewind, we'll continue parsing as usual\n    // If no \"shouldStop\" option was provided, we should have consumed the whole\n    // input.\n\n    if (!shouldStop) scanner.fatal(\"Expected EOF\");\n  }\n\n  return result;\n}\n\nfunction codePointToString(cp) {\n  if (cp >= 0 && cp <= 0xD7FF || cp >= 0xE000 && cp <= 0xFFFF) {\n    return String.fromCharCode(cp);\n  } else if (cp >= 0x10000 && cp <= 0x10FFFF) {\n    // we substract 0x10000 from cp to get a 20-bit number\n    // in the range 0..0xFFFF\n    cp -= 0x10000; // we add 0xD800 to the number formed by the first 10 bits\n    // to give the first byte\n\n    var first = ((0xffc00 & cp) >> 10) + 0xD800; // we add 0xDC00 to the number formed by the low 10 bits\n    // to give the second byte\n\n    var second = (0x3ff & cp) + 0xDC00;\n    return String.fromCharCode(first) + String.fromCharCode(second);\n  } else {\n    return '';\n  }\n}\n\nfunction getContent(scanner, shouldStopFunc) {\n  var items = [];\n\n  while (!scanner.isEOF()) {\n    if (shouldStopFunc && shouldStopFunc(scanner)) break;\n    var posBefore = scanner.pos;\n    var token = getHTMLToken(scanner);\n    if (!token) // tokenizer reached EOF on its own, e.g. while scanning\n      // template comments like `{{! foo}}`.\n      continue;\n\n    if (token.t === 'Doctype') {\n      scanner.fatal(\"Unexpected Doctype\");\n    } else if (token.t === 'Chars') {\n      pushOrAppendString(items, token.v);\n    } else if (token.t === 'CharRef') {\n      items.push(convertCharRef(token));\n    } else if (token.t === 'Comment') {\n      items.push(HTML.Comment(token.v));\n    } else if (token.t === 'TemplateTag') {\n      items.push(token.v);\n    } else if (token.t === 'Tag') {\n      if (token.isEnd) {\n        // Stop when we encounter an end tag at the top level.\n        // Rewind; we'll re-parse the end tag later.\n        scanner.pos = posBefore;\n        break;\n      }\n\n      var tagName = token.n; // is this an element with no close tag (a BR, HR, IMG, etc.) based\n      // on its name?\n\n      var isVoid = HTML.isVoidElement(tagName);\n\n      if (token.isSelfClosing) {\n        if (!(isVoid || HTML.isKnownSVGElement(tagName) || tagName.indexOf(':') >= 0)) scanner.fatal('Only certain elements like BR, HR, IMG, etc. (and foreign elements like SVG) are allowed to self-close');\n      } // result of parseAttrs may be null\n\n\n      var attrs = parseAttrs(token.attrs); // arrays need to be wrapped in HTML.Attrs(...)\n      // when used to construct tags\n\n      if (HTML.isArray(attrs)) attrs = HTML.Attrs.apply(null, attrs);\n      var tagFunc = HTML.getTag(tagName);\n\n      if (isVoid || token.isSelfClosing) {\n        items.push(attrs ? tagFunc(attrs) : tagFunc());\n      } else {\n        // parse HTML tag contents.\n        // HTML treats a final `/` in a tag as part of an attribute, as in `<a href=/foo/>`, but the template author who writes `<circle r={{r}}/>`, say, may not be thinking about that, so generate a good error message in the \"looks like self-close\" case.\n        var looksLikeSelfClose = scanner.input.substr(scanner.pos - 2, 2) === '/>';\n        var content = null;\n\n        if (token.n === 'textarea') {\n          if (scanner.peek() === '\\n') scanner.pos++;\n          var textareaValue = getRCData(scanner, token.n, shouldStopFunc);\n\n          if (textareaValue) {\n            if (attrs instanceof HTML.Attrs) {\n              attrs = HTML.Attrs.apply(null, attrs.value.concat([{\n                value: textareaValue\n              }]));\n            } else {\n              attrs = attrs || {};\n              attrs.value = textareaValue;\n            }\n          }\n        } else if (token.n === 'script' || token.n === 'style') {\n          content = getRawText(scanner, token.n, shouldStopFunc);\n        } else {\n          content = getContent(scanner, shouldStopFunc);\n        }\n\n        var endTag = getHTMLToken(scanner);\n        if (!(endTag && endTag.t === 'Tag' && endTag.isEnd && endTag.n === tagName)) scanner.fatal('Expected \"' + tagName + '\" end tag' + (looksLikeSelfClose ? ' -- if the \"<' + token.n + ' />\" tag was supposed to self-close, try adding a space before the \"/\"' : '')); // XXX support implied end tags in cases allowed by the spec\n        // make `content` into an array suitable for applying tag constructor\n        // as in `FOO.apply(null, content)`.\n\n        if (content == null) content = [];else if (!HTML.isArray(content)) content = [content];\n        items.push(HTML.getTag(tagName).apply(null, (attrs ? [attrs] : []).concat(content)));\n      }\n    } else {\n      scanner.fatal(\"Unknown token type: \" + token.t);\n    }\n  }\n\n  if (items.length === 0) return null;else if (items.length === 1) return items[0];else return items;\n}\n\nvar pushOrAppendString = function (items, string) {\n  if (items.length && typeof items[items.length - 1] === 'string') items[items.length - 1] += string;else items.push(string);\n}; // get RCDATA to go in the lowercase (or camel case) tagName (e.g. \"textarea\")\n\n\nfunction getRCData(scanner, tagName, shouldStopFunc) {\n  var items = [];\n\n  while (!scanner.isEOF()) {\n    // break at appropriate end tag\n    if (tagName && isLookingAtEndTag(scanner, tagName)) break;\n    if (shouldStopFunc && shouldStopFunc(scanner)) break;\n    var token = getHTMLToken(scanner, 'rcdata');\n    if (!token) // tokenizer reached EOF on its own, e.g. while scanning\n      // template comments like `{{! foo}}`.\n      continue;\n\n    if (token.t === 'Chars') {\n      pushOrAppendString(items, token.v);\n    } else if (token.t === 'CharRef') {\n      items.push(convertCharRef(token));\n    } else if (token.t === 'TemplateTag') {\n      items.push(token.v);\n    } else {\n      // (can't happen)\n      scanner.fatal(\"Unknown or unexpected token type: \" + token.t);\n    }\n  }\n\n  if (items.length === 0) return null;else if (items.length === 1) return items[0];else return items;\n}\n\nvar getRawText = function (scanner, tagName, shouldStopFunc) {\n  var items = [];\n\n  while (!scanner.isEOF()) {\n    // break at appropriate end tag\n    if (tagName && isLookingAtEndTag(scanner, tagName)) break;\n    if (shouldStopFunc && shouldStopFunc(scanner)) break;\n    var token = getHTMLToken(scanner, 'rawtext');\n    if (!token) // tokenizer reached EOF on its own, e.g. while scanning\n      // template comments like `{{! foo}}`.\n      continue;\n\n    if (token.t === 'Chars') {\n      pushOrAppendString(items, token.v);\n    } else if (token.t === 'TemplateTag') {\n      items.push(token.v);\n    } else {\n      // (can't happen)\n      scanner.fatal(\"Unknown or unexpected token type: \" + token.t);\n    }\n  }\n\n  if (items.length === 0) return null;else if (items.length === 1) return items[0];else return items;\n}; // Input: A token like `{ t: 'CharRef', v: '&amp;', cp: [38] }`.\n//\n// Output: A tag like `HTML.CharRef({ html: '&amp;', str: '&' })`.\n\n\nvar convertCharRef = function (token) {\n  var codePoints = token.cp;\n  var str = '';\n\n  for (var i = 0; i < codePoints.length; i++) str += codePointToString(codePoints[i]);\n\n  return HTML.CharRef({\n    html: token.v,\n    str: str\n  });\n}; // Input is always a dictionary (even if zero attributes) and each\n// value in the dictionary is an array of `Chars`, `CharRef`,\n// and maybe `TemplateTag` tokens.\n//\n// Output is null if there are zero attributes, and otherwise a\n// dictionary, or an array of dictionaries and template tags.\n// Each value in the dictionary is HTMLjs (e.g. a\n// string or an array of `Chars`, `CharRef`, and `TemplateTag`\n// nodes).\n//\n// An attribute value with no input tokens is represented as \"\",\n// not an empty array, in order to prop open empty attributes\n// with no template tags.\n\n\nvar parseAttrs = function (attrs) {\n  var result = null;\n\n  if (HTML.isArray(attrs)) {\n    // first element is nondynamic attrs, rest are template tags\n    var nondynamicAttrs = parseAttrs(attrs[0]);\n\n    if (nondynamicAttrs) {\n      result = result || [];\n      result.push(nondynamicAttrs);\n    }\n\n    for (var i = 1; i < attrs.length; i++) {\n      var token = attrs[i];\n      if (token.t !== 'TemplateTag') throw new Error(\"Expected TemplateTag token\");\n      result = result || [];\n      result.push(token.v);\n    }\n\n    return result;\n  }\n\n  for (var k in attrs) {\n    if (!result) result = {};\n    var inValue = attrs[k];\n    var outParts = [];\n\n    for (var i = 0; i < inValue.length; i++) {\n      var token = inValue[i];\n\n      if (token.t === 'CharRef') {\n        outParts.push(convertCharRef(token));\n      } else if (token.t === 'TemplateTag') {\n        outParts.push(token.v);\n      } else if (token.t === 'Chars') {\n        pushOrAppendString(outParts, token.v);\n      }\n    }\n\n    var outValue = inValue.length === 0 ? '' : outParts.length === 1 ? outParts[0] : outParts;\n    var properKey = properCaseAttributeName(k);\n    result[properKey] = outValue;\n  }\n\n  return result;\n};","map":{"version":3,"sources":["packages/html-tools/parse.js"],"names":["module","export","parseFragment","codePointToString","getContent","getRCData","HTML","link","v","Scanner","properCaseAttributeName","getHTMLToken","isLookingAtEndTag","input","options","scanner","getTemplateTag","shouldStop","result","textMode","TEXTMODE","STRING","getRawText","RCDATA","Error","isEOF","posBefore","pos","endTag","e","t","isEnd","closeTag","n","isVoidElement","fatal","cp","String","fromCharCode","first","second","shouldStopFunc","items","token","pushOrAppendString","push","convertCharRef","Comment","tagName","isVoid","isSelfClosing","isKnownSVGElement","indexOf","attrs","parseAttrs","isArray","Attrs","apply","tagFunc","getTag","looksLikeSelfClose","substr","content","peek","textareaValue","value","concat","length","string","codePoints","str","i","CharRef","html","nondynamicAttrs","k","inValue","outParts","outValue","properKey"],"mappings":"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","sourcesContent":["import { HTML } from 'meteor/htmljs';\nimport { Scanner } from './scanner';\nimport { properCaseAttributeName } from './utils';\nimport { getHTMLToken, isLookingAtEndTag } from './tokenize';\n\n// Parse a \"fragment\" of HTML, up to the end of the input or a particular\n// template tag (using the \"shouldStop\" option).\nexport function parseFragment(input, options) {\n  var scanner;\n  if (typeof input === 'string')\n    scanner = new Scanner(input);\n  else\n    // input can be a scanner.  We'd better not have a different\n    // value for the \"getTemplateTag\" option as when the scanner\n    // was created, because we don't do anything special to reset\n    // the value (which is attached to the scanner).\n    scanner = input;\n\n  // ```\n  // { getTemplateTag: function (scanner, templateTagPosition) {\n  //     if (templateTagPosition === HTMLTools.TEMPLATE_TAG_POSITION.ELEMENT) {\n  //       ...\n  // ```\n  if (options && options.getTemplateTag)\n    scanner.getTemplateTag = options.getTemplateTag;\n\n  // function (scanner) -> boolean\n  var shouldStop = options && options.shouldStop;\n\n  var result;\n  if (options && options.textMode) {\n    if (options.textMode === HTML.TEXTMODE.STRING) {\n      result = getRawText(scanner, null, shouldStop);\n    } else if (options.textMode === HTML.TEXTMODE.RCDATA) {\n      result = getRCData(scanner, null, shouldStop);\n    } else {\n      throw new Error(\"Unsupported textMode: \" + options.textMode);\n    }\n  } else {\n    result = getContent(scanner, shouldStop);\n  }\n  if (! scanner.isEOF()) {\n    // If we aren't at the end of the input, we either stopped at an unmatched\n    // HTML end tag or at a template tag (like `{{else}}` or `{{/if}}`).\n    // Detect the former case (stopped at an HTML end tag) and throw a good\n    // error.\n\n    var posBefore = scanner.pos;\n\n    try {\n      var endTag = getHTMLToken(scanner);\n    } catch (e) {\n      // ignore errors from getTemplateTag\n    }\n\n    // XXX we make some assumptions about shouldStop here, like that it\n    // won't tell us to stop at an HTML end tag.  Should refactor\n    // `shouldStop` into something more suitable.\n    if (endTag && endTag.t === 'Tag' && endTag.isEnd) {\n      var closeTag = endTag.n;\n      var isVoidElement = HTML.isVoidElement(closeTag);\n      scanner.fatal(\"Unexpected HTML close tag\" +\n                    (isVoidElement ?\n                     '.  <' + endTag.n + '> should have no close tag.' : ''));\n    }\n\n    scanner.pos = posBefore; // rewind, we'll continue parsing as usual\n\n    // If no \"shouldStop\" option was provided, we should have consumed the whole\n    // input.\n    if (! shouldStop)\n      scanner.fatal(\"Expected EOF\");\n  }\n\n  return result;\n}\n\n// Take a numeric Unicode code point, which may be larger than 16 bits,\n// and encode it as a JavaScript UTF-16 string.\n//\n// Adapted from\n// http://stackoverflow.com/questions/7126384/expressing-utf-16-unicode-characters-in-javascript/7126661.\nexport function codePointToString(cp) {\n  if (cp >= 0 && cp <= 0xD7FF || cp >= 0xE000 && cp <= 0xFFFF) {\n    return String.fromCharCode(cp);\n  } else if (cp >= 0x10000 && cp <= 0x10FFFF) {\n\n    // we substract 0x10000 from cp to get a 20-bit number\n    // in the range 0..0xFFFF\n    cp -= 0x10000;\n\n    // we add 0xD800 to the number formed by the first 10 bits\n    // to give the first byte\n    var first = ((0xffc00 & cp) >> 10) + 0xD800;\n\n    // we add 0xDC00 to the number formed by the low 10 bits\n    // to give the second byte\n    var second = (0x3ff & cp) + 0xDC00;\n\n    return String.fromCharCode(first) + String.fromCharCode(second);\n  } else {\n    return '';\n  }\n}\n\nexport function getContent (scanner, shouldStopFunc) {\n  var items = [];\n\n  while (! scanner.isEOF()) {\n    if (shouldStopFunc && shouldStopFunc(scanner))\n      break;\n\n    var posBefore = scanner.pos;\n    var token = getHTMLToken(scanner);\n    if (! token)\n      // tokenizer reached EOF on its own, e.g. while scanning\n      // template comments like `{{! foo}}`.\n      continue;\n\n    if (token.t === 'Doctype') {\n      scanner.fatal(\"Unexpected Doctype\");\n    } else if (token.t === 'Chars') {\n      pushOrAppendString(items, token.v);\n    } else if (token.t === 'CharRef') {\n      items.push(convertCharRef(token));\n    } else if (token.t === 'Comment') {\n      items.push(HTML.Comment(token.v));\n    } else if (token.t === 'TemplateTag') {\n      items.push(token.v);\n    } else if (token.t === 'Tag') {\n      if (token.isEnd) {\n        // Stop when we encounter an end tag at the top level.\n        // Rewind; we'll re-parse the end tag later.\n        scanner.pos = posBefore;\n        break;\n      }\n\n      var tagName = token.n;\n      // is this an element with no close tag (a BR, HR, IMG, etc.) based\n      // on its name?\n      var isVoid = HTML.isVoidElement(tagName);\n      if (token.isSelfClosing) {\n        if (! (isVoid || HTML.isKnownSVGElement(tagName) || tagName.indexOf(':') >= 0))\n          scanner.fatal('Only certain elements like BR, HR, IMG, etc. (and foreign elements like SVG) are allowed to self-close');\n      }\n\n      // result of parseAttrs may be null\n      var attrs = parseAttrs(token.attrs);\n      // arrays need to be wrapped in HTML.Attrs(...)\n      // when used to construct tags\n      if (HTML.isArray(attrs))\n        attrs = HTML.Attrs.apply(null, attrs);\n\n      var tagFunc = HTML.getTag(tagName);\n      if (isVoid || token.isSelfClosing) {\n        items.push(attrs ? tagFunc(attrs) : tagFunc());\n      } else {\n        // parse HTML tag contents.\n\n        // HTML treats a final `/` in a tag as part of an attribute, as in `<a href=/foo/>`, but the template author who writes `<circle r={{r}}/>`, say, may not be thinking about that, so generate a good error message in the \"looks like self-close\" case.\n        var looksLikeSelfClose = (scanner.input.substr(scanner.pos - 2, 2) === '/>');\n\n        var content = null;\n        if (token.n === 'textarea') {\n          if (scanner.peek() === '\\n')\n            scanner.pos++;\n          var textareaValue = getRCData(scanner, token.n, shouldStopFunc);\n          if (textareaValue) {\n            if (attrs instanceof HTML.Attrs) {\n              attrs = HTML.Attrs.apply(\n                null, attrs.value.concat([{value: textareaValue}]));\n            } else {\n              attrs = (attrs || {});\n              attrs.value = textareaValue;\n            }\n          }\n        } else if (token.n === 'script' || token.n === 'style') {\n          content = getRawText(scanner, token.n, shouldStopFunc);\n        } else {\n          content = getContent(scanner, shouldStopFunc);\n        }\n\n        var endTag = getHTMLToken(scanner);\n\n        if (! (endTag && endTag.t === 'Tag' && endTag.isEnd && endTag.n === tagName))\n          scanner.fatal('Expected \"' + tagName + '\" end tag' + (looksLikeSelfClose ? ' -- if the \"<' + token.n + ' />\" tag was supposed to self-close, try adding a space before the \"/\"' : ''));\n\n        // XXX support implied end tags in cases allowed by the spec\n\n        // make `content` into an array suitable for applying tag constructor\n        // as in `FOO.apply(null, content)`.\n        if (content == null)\n          content = [];\n        else if (! HTML.isArray(content))\n          content = [content];\n\n        items.push(HTML.getTag(tagName).apply(\n          null, (attrs ? [attrs] : []).concat(content)));\n      }\n    } else {\n      scanner.fatal(\"Unknown token type: \" + token.t);\n    }\n  }\n\n  if (items.length === 0)\n    return null;\n  else if (items.length === 1)\n    return items[0];\n  else\n    return items;\n}\n\nvar pushOrAppendString = function (items, string) {\n  if (items.length &&\n      typeof items[items.length - 1] === 'string')\n    items[items.length - 1] += string;\n  else\n    items.push(string);\n};\n\n// get RCDATA to go in the lowercase (or camel case) tagName (e.g. \"textarea\")\nexport function getRCData(scanner, tagName, shouldStopFunc) {\n  var items = [];\n\n  while (! scanner.isEOF()) {\n    // break at appropriate end tag\n    if (tagName && isLookingAtEndTag(scanner, tagName))\n      break;\n\n    if (shouldStopFunc && shouldStopFunc(scanner))\n      break;\n\n    var token = getHTMLToken(scanner, 'rcdata');\n    if (! token)\n      // tokenizer reached EOF on its own, e.g. while scanning\n      // template comments like `{{! foo}}`.\n      continue;\n\n    if (token.t === 'Chars') {\n      pushOrAppendString(items, token.v);\n    } else if (token.t === 'CharRef') {\n      items.push(convertCharRef(token));\n    } else if (token.t === 'TemplateTag') {\n      items.push(token.v);\n    } else {\n      // (can't happen)\n      scanner.fatal(\"Unknown or unexpected token type: \" + token.t);\n    }\n  }\n\n  if (items.length === 0)\n    return null;\n  else if (items.length === 1)\n    return items[0];\n  else\n    return items;\n}\n\nvar getRawText = function (scanner, tagName, shouldStopFunc) {\n  var items = [];\n\n  while (! scanner.isEOF()) {\n    // break at appropriate end tag\n    if (tagName && isLookingAtEndTag(scanner, tagName))\n      break;\n\n    if (shouldStopFunc && shouldStopFunc(scanner))\n      break;\n\n    var token = getHTMLToken(scanner, 'rawtext');\n    if (! token)\n      // tokenizer reached EOF on its own, e.g. while scanning\n      // template comments like `{{! foo}}`.\n      continue;\n\n    if (token.t === 'Chars') {\n      pushOrAppendString(items, token.v);\n    } else if (token.t === 'TemplateTag') {\n      items.push(token.v);\n    } else {\n      // (can't happen)\n      scanner.fatal(\"Unknown or unexpected token type: \" + token.t);\n    }\n  }\n\n  if (items.length === 0)\n    return null;\n  else if (items.length === 1)\n    return items[0];\n  else\n    return items;\n};\n\n// Input: A token like `{ t: 'CharRef', v: '&amp;', cp: [38] }`.\n//\n// Output: A tag like `HTML.CharRef({ html: '&amp;', str: '&' })`.\nvar convertCharRef = function (token) {\n  var codePoints = token.cp;\n  var str = '';\n  for (var i = 0; i < codePoints.length; i++)\n    str += codePointToString(codePoints[i]);\n  return HTML.CharRef({ html: token.v, str: str });\n};\n\n// Input is always a dictionary (even if zero attributes) and each\n// value in the dictionary is an array of `Chars`, `CharRef`,\n// and maybe `TemplateTag` tokens.\n//\n// Output is null if there are zero attributes, and otherwise a\n// dictionary, or an array of dictionaries and template tags.\n// Each value in the dictionary is HTMLjs (e.g. a\n// string or an array of `Chars`, `CharRef`, and `TemplateTag`\n// nodes).\n//\n// An attribute value with no input tokens is represented as \"\",\n// not an empty array, in order to prop open empty attributes\n// with no template tags.\nvar parseAttrs = function (attrs) {\n  var result = null;\n\n  if (HTML.isArray(attrs)) {\n    // first element is nondynamic attrs, rest are template tags\n    var nondynamicAttrs = parseAttrs(attrs[0]);\n    if (nondynamicAttrs) {\n      result = (result || []);\n      result.push(nondynamicAttrs);\n    }\n    for (var i = 1; i < attrs.length; i++) {\n      var token = attrs[i];\n      if (token.t !== 'TemplateTag')\n        throw new Error(\"Expected TemplateTag token\");\n      result = (result || []);\n      result.push(token.v);\n    }\n    return result;\n  }\n\n  for (var k in attrs) {\n    if (! result)\n      result = {};\n\n    var inValue = attrs[k];\n    var outParts = [];\n    for (var i = 0; i < inValue.length; i++) {\n      var token = inValue[i];\n      if (token.t === 'CharRef') {\n        outParts.push(convertCharRef(token));\n      } else if (token.t === 'TemplateTag') {\n        outParts.push(token.v);\n      } else if (token.t === 'Chars') {\n        pushOrAppendString(outParts, token.v);\n      }\n    }\n\n    var outValue = (inValue.length === 0 ? '' :\n                    (outParts.length === 1 ? outParts[0] : outParts));\n    var properKey = properCaseAttributeName(k);\n    result[properKey] = outValue;\n  }\n\n  return result;\n};\n"]},"sourceType":"module","hash":"6c596acd2c86bb8aee0acf84c56ad6d3f9ec4184"}
