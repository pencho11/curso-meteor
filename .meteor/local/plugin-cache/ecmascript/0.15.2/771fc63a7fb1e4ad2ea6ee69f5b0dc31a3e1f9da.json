{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"C:\\Users\\RUBEN\\Desktop\\meteor-vue\\packages\\html-tools\\scanner.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.windows.x86_64"},"sourceFileName":"packages/html-tools/scanner.js","filename":"C:\\Users\\RUBEN\\Desktop\\meteor-vue\\packages\\html-tools\\scanner.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"C:\\Users\\RUBEN\\Desktop\\meteor-vue","root":"C:\\Users\\RUBEN\\Desktop\\meteor-vue","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true}},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.14.0","helpers":true,"useESModules":false,"corejs":false}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":true,"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_verified":true},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}}],"presets":[],"generatorOpts":{"filename":"C:\\Users\\RUBEN\\Desktop\\meteor-vue\\packages\\html-tools\\scanner.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/html-tools/scanner.js"}},"code":"module.export({\n  Scanner: () => Scanner,\n  makeRegexMatcher: () => makeRegexMatcher\n});\n\nfunction Scanner(input) {\n  this.input = input; // public, read-only\n\n  this.pos = 0; // public, read-write\n}\n\nScanner.prototype.rest = function () {\n  // Slicing a string is O(1) in modern JavaScript VMs (including old IE).\n  return this.input.slice(this.pos);\n};\n\nScanner.prototype.isEOF = function () {\n  return this.pos >= this.input.length;\n};\n\nScanner.prototype.fatal = function (msg) {\n  // despite this default, you should always provide a message!\n  msg = msg || \"Parse error\";\n  var CONTEXT_AMOUNT = 20;\n  var input = this.input;\n  var pos = this.pos;\n  var pastInput = input.substring(pos - CONTEXT_AMOUNT - 1, pos);\n  if (pastInput.length > CONTEXT_AMOUNT) pastInput = '...' + pastInput.substring(-CONTEXT_AMOUNT);\n  var upcomingInput = input.substring(pos, pos + CONTEXT_AMOUNT + 1);\n  if (upcomingInput.length > CONTEXT_AMOUNT) upcomingInput = upcomingInput.substring(0, CONTEXT_AMOUNT) + '...';\n  var positionDisplay = (pastInput + upcomingInput).replace(/\\n/g, ' ') + '\\n' + new Array(pastInput.length + 1).join(' ') + \"^\";\n  var e = new Error(msg + \"\\n\" + positionDisplay);\n  e.offset = pos;\n  var allPastInput = input.substring(0, pos);\n  e.line = 1 + (allPastInput.match(/\\n/g) || []).length;\n  e.col = 1 + pos - allPastInput.lastIndexOf('\\n');\n  e.scanner = this;\n  throw e;\n}; // Peek at the next character.\n//\n// If `isEOF`, returns an empty string.\n\n\nScanner.prototype.peek = function () {\n  return this.input.charAt(this.pos);\n}; // Constructs a `getFoo` function where `foo` is specified with a regex.\n// The regex should start with `^`.  The constructed function will return\n// match group 1, if it exists and matches a non-empty string, or else\n// the entire matched string (or null if there is no match).\n//\n// A `getFoo` function tries to match and consume a foo.  If it succeeds,\n// the current position of the scanner is advanced.  If it fails, the\n// current position is not advanced and a falsy value (typically null)\n// is returned.\n\n\nfunction makeRegexMatcher(regex) {\n  return function (scanner) {\n    var match = regex.exec(scanner.rest());\n    if (!match) return null;\n    scanner.pos += match[0].length;\n    return match[1] || match[0];\n  };\n}","map":{"version":3,"sources":["packages/html-tools/scanner.js"],"names":["module","export","Scanner","makeRegexMatcher","input","pos","prototype","rest","slice","isEOF","length","fatal","msg","CONTEXT_AMOUNT","pastInput","substring","upcomingInput","positionDisplay","replace","Array","join","e","Error","offset","allPastInput","line","match","col","lastIndexOf","scanner","peek","charAt","regex","exec"],"mappings":"AAAAA,MAAM,CAACC,MAAP,CAAc;AAACC,EAAAA,OAAO,EAAC,MAAIA,OAAb;AAAqBC,EAAAA,gBAAgB,EAAC,MAAIA;AAA1C,CAAd;;AAWO,SAASD,OAAT,CAAkBE,KAAlB,EAAyB;AAC9B,OAAKA,KAAL,GAAaA,KAAb,CAD8B,CACV;;AACpB,OAAKC,GAAL,GAAW,CAAX,CAF8B,CAEhB;AACf;;AAEDH,OAAO,CAACI,SAAR,CAAkBC,IAAlB,GAAyB,YAAY;AACnC;AACA,SAAO,KAAKH,KAAL,CAAWI,KAAX,CAAiB,KAAKH,GAAtB,CAAP;AACD,CAHD;;AAKAH,OAAO,CAACI,SAAR,CAAkBG,KAAlB,GAA0B,YAAY;AACpC,SAAO,KAAKJ,GAAL,IAAY,KAAKD,KAAL,CAAWM,MAA9B;AACD,CAFD;;AAIAR,OAAO,CAACI,SAAR,CAAkBK,KAAlB,GAA0B,UAAUC,GAAV,EAAe;AACvC;AACAA,EAAAA,GAAG,GAAIA,GAAG,IAAI,aAAd;AAEA,MAAIC,cAAc,GAAG,EAArB;AAEA,MAAIT,KAAK,GAAG,KAAKA,KAAjB;AACA,MAAIC,GAAG,GAAG,KAAKA,GAAf;AACA,MAAIS,SAAS,GAAGV,KAAK,CAACW,SAAN,CAAgBV,GAAG,GAAGQ,cAAN,GAAuB,CAAvC,EAA0CR,GAA1C,CAAhB;AACA,MAAIS,SAAS,CAACJ,MAAV,GAAmBG,cAAvB,EACEC,SAAS,GAAG,QAAQA,SAAS,CAACC,SAAV,CAAoB,CAACF,cAArB,CAApB;AAEF,MAAIG,aAAa,GAAGZ,KAAK,CAACW,SAAN,CAAgBV,GAAhB,EAAqBA,GAAG,GAAGQ,cAAN,GAAuB,CAA5C,CAApB;AACA,MAAIG,aAAa,CAACN,MAAd,GAAuBG,cAA3B,EACEG,aAAa,GAAGA,aAAa,CAACD,SAAd,CAAwB,CAAxB,EAA2BF,cAA3B,IAA6C,KAA7D;AAEF,MAAII,eAAe,GAAI,CAACH,SAAS,GAAGE,aAAb,EAA4BE,OAA5B,CAAoC,KAApC,EAA2C,GAA3C,IAAkD,IAAlD,GACC,IAAIC,KAAJ,CAAUL,SAAS,CAACJ,MAAV,GAAmB,CAA7B,EAAgCU,IAAhC,CAAqC,GAArC,CADD,GAC8C,GADrE;AAGA,MAAIC,CAAC,GAAG,IAAIC,KAAJ,CAAUV,GAAG,GAAG,IAAN,GAAaK,eAAvB,CAAR;AAEAI,EAAAA,CAAC,CAACE,MAAF,GAAWlB,GAAX;AACA,MAAImB,YAAY,GAAGpB,KAAK,CAACW,SAAN,CAAgB,CAAhB,EAAmBV,GAAnB,CAAnB;AACAgB,EAAAA,CAAC,CAACI,IAAF,GAAU,IAAI,CAACD,YAAY,CAACE,KAAb,CAAmB,KAAnB,KAA6B,EAA9B,EAAkChB,MAAhD;AACAW,EAAAA,CAAC,CAACM,GAAF,GAAS,IAAItB,GAAJ,GAAUmB,YAAY,CAACI,WAAb,CAAyB,IAAzB,CAAnB;AACAP,EAAAA,CAAC,CAACQ,OAAF,GAAY,IAAZ;AAEA,QAAMR,CAAN;AACD,CA5BD,C,CA8BA;AACA;AACA;;;AACAnB,OAAO,CAACI,SAAR,CAAkBwB,IAAlB,GAAyB,YAAY;AACnC,SAAO,KAAK1B,KAAL,CAAW2B,MAAX,CAAkB,KAAK1B,GAAvB,CAAP;AACD,CAFD,C,CAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACO,SAASF,gBAAT,CAA0B6B,KAA1B,EAAiC;AACtC,SAAO,UAAUH,OAAV,EAAmB;AACxB,QAAIH,KAAK,GAAGM,KAAK,CAACC,IAAN,CAAWJ,OAAO,CAACtB,IAAR,EAAX,CAAZ;AAEA,QAAI,CAAEmB,KAAN,EACE,OAAO,IAAP;AAEFG,IAAAA,OAAO,CAACxB,GAAR,IAAeqB,KAAK,CAAC,CAAD,CAAL,CAAShB,MAAxB;AACA,WAAOgB,KAAK,CAAC,CAAD,CAAL,IAAYA,KAAK,CAAC,CAAD,CAAxB;AACD,GARD;AASD","sourcesContent":["// This is a Scanner class suitable for any parser/lexer/tokenizer.\n//\n// A Scanner has an immutable source document (string) `input` and a current\n// position `pos`, an index into the string, which can be set at will.\n//\n// * `new Scanner(input)` - constructs a Scanner with source string `input`\n// * `scanner.rest()` - returns the rest of the input after `pos`\n// * `scanner.peek()` - returns the character at `pos`\n// * `scanner.isEOF()` - true if `pos` is at or beyond the end of `input`\n// * `scanner.fatal(msg)` - throw an error indicating a problem at `pos`\n\nexport function Scanner (input) {\n  this.input = input; // public, read-only\n  this.pos = 0; // public, read-write\n}\n\nScanner.prototype.rest = function () {\n  // Slicing a string is O(1) in modern JavaScript VMs (including old IE).\n  return this.input.slice(this.pos);\n};\n\nScanner.prototype.isEOF = function () {\n  return this.pos >= this.input.length;\n};\n\nScanner.prototype.fatal = function (msg) {\n  // despite this default, you should always provide a message!\n  msg = (msg || \"Parse error\");\n\n  var CONTEXT_AMOUNT = 20;\n\n  var input = this.input;\n  var pos = this.pos;\n  var pastInput = input.substring(pos - CONTEXT_AMOUNT - 1, pos);\n  if (pastInput.length > CONTEXT_AMOUNT)\n    pastInput = '...' + pastInput.substring(-CONTEXT_AMOUNT);\n\n  var upcomingInput = input.substring(pos, pos + CONTEXT_AMOUNT + 1);\n  if (upcomingInput.length > CONTEXT_AMOUNT)\n    upcomingInput = upcomingInput.substring(0, CONTEXT_AMOUNT) + '...';\n\n  var positionDisplay = ((pastInput + upcomingInput).replace(/\\n/g, ' ') + '\\n' +\n                         (new Array(pastInput.length + 1).join(' ')) + \"^\");\n\n  var e = new Error(msg + \"\\n\" + positionDisplay);\n\n  e.offset = pos;\n  var allPastInput = input.substring(0, pos);\n  e.line = (1 + (allPastInput.match(/\\n/g) || []).length);\n  e.col = (1 + pos - allPastInput.lastIndexOf('\\n'));\n  e.scanner = this;\n\n  throw e;\n};\n\n// Peek at the next character.\n//\n// If `isEOF`, returns an empty string.\nScanner.prototype.peek = function () {\n  return this.input.charAt(this.pos);\n};\n\n// Constructs a `getFoo` function where `foo` is specified with a regex.\n// The regex should start with `^`.  The constructed function will return\n// match group 1, if it exists and matches a non-empty string, or else\n// the entire matched string (or null if there is no match).\n//\n// A `getFoo` function tries to match and consume a foo.  If it succeeds,\n// the current position of the scanner is advanced.  If it fails, the\n// current position is not advanced and a falsy value (typically null)\n// is returned.\nexport function makeRegexMatcher(regex) {\n  return function (scanner) {\n    var match = regex.exec(scanner.rest());\n\n    if (! match)\n      return null;\n\n    scanner.pos += match[0].length;\n    return match[1] || match[0];\n  };\n}\n"]},"sourceType":"module","hash":"771fc63a7fb1e4ad2ea6ee69f5b0dc31a3e1f9da"}
